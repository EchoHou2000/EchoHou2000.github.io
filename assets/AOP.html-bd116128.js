const e=JSON.parse('{"key":"v-1d94f08f","path":"/posts/Java/AOP.html","title":"我是怎么用Spring AOP的？","lang":"zh-CN","frontmatter":{"date":"2023-10-11T00:00:00.000Z","category":["Web开发"],"tag":["Spring"],"description":"我是怎么用Spring AOP的？ 业务需求 项目中需要对前端的元素、接口进行权限控制，如果权限不足，无法访问。而后端又有很多接口需要进行权限判断，每个接口都进行判断，会有很多重复性的代码，可维护性不高。 思路 所以我们需要把这些公共的代码抽出来，我们编写业务代码的时候，只需要关注具体不同的逻辑即可，不用写大量重复性的代码。而具体的业务逻辑相当于一个\\"织入\\"进去的操作。 在这个过程中，我们抽出来不是关键业务的同一类方法，并且封装成一个类用来判断权限。 Spring AOP就是在某些方法前后执行一些通用的操作，而这些操作又不会影响程序本身的正常执行，比如日志操作、权限判断。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blogs/posts/Java/AOP.html"}],["meta",{"property":"og:site_name","content":"Echo的学习之路"}],["meta",{"property":"og:title","content":"我是怎么用Spring AOP的？"}],["meta",{"property":"og:description","content":"我是怎么用Spring AOP的？ 业务需求 项目中需要对前端的元素、接口进行权限控制，如果权限不足，无法访问。而后端又有很多接口需要进行权限判断，每个接口都进行判断，会有很多重复性的代码，可维护性不高。 思路 所以我们需要把这些公共的代码抽出来，我们编写业务代码的时候，只需要关注具体不同的逻辑即可，不用写大量重复性的代码。而具体的业务逻辑相当于一个\\"织入\\"进去的操作。 在这个过程中，我们抽出来不是关键业务的同一类方法，并且封装成一个类用来判断权限。 Spring AOP就是在某些方法前后执行一些通用的操作，而这些操作又不会影响程序本身的正常执行，比如日志操作、权限判断。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-21T13:57:41.000Z"}],["meta",{"property":"article:author","content":"Echo Hou"}],["meta",{"property":"article:tag","content":"Spring"}],["meta",{"property":"article:published_time","content":"2023-10-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-21T13:57:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"我是怎么用Spring AOP的？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-11T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-21T13:57:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Echo Hou\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"业务需求","slug":"业务需求","link":"#业务需求","children":[]},{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[{"level":3,"title":"一、声明注解","slug":"一、声明注解","link":"#一、声明注解","children":[]},{"level":3,"title":"二、定义切面。","slug":"二、定义切面。","link":"#二、定义切面。","children":[]},{"level":3,"title":"三、应用注解","slug":"三、应用注解","link":"#三、应用注解","children":[]}]},{"level":2,"title":"Spring AOP的实现原理","slug":"spring-aop的实现原理","link":"#spring-aop的实现原理","children":[]}],"git":{"createdTime":1698759795000,"updatedTime":1700575061000,"contributors":[{"name":"houbingzhi123","email":"houbingzhi123@gmail.com","commits":2}]},"readingTime":{"minutes":3.52,"words":1057},"filePathRelative":"posts/Java/AOP.md","localizedDate":"2023年10月11日","excerpt":"<h1> 我是怎么用Spring AOP的？</h1>\\n<h2> 业务需求</h2>\\n<p>项目中需要对前端的元素、接口进行权限控制，如果权限不足，无法访问。而后端又有很多接口需要进行权限判断，每个接口都进行判断，会有很多重复性的代码，可维护性不高。</p>\\n<h2> 思路</h2>\\n<p>所以我们需要把这些公共的代码抽出来，我们编写业务代码的时候，只需要关注具体不同的逻辑即可，不用写大量重复性的代码。而具体的业务逻辑相当于一个\\"织入\\"进去的操作。</p>\\n<p>在这个过程中，我们抽出来不是关键业务的同一类方法，并且封装成一个类用来判断权限。</p>\\n<p><strong>Spring AOP</strong>就是在某些方法前后执行一些通用的操作，而这些操作又不会影响程序本身的正常执行，比如日志操作、权限判断。</p>","autoDesc":true}');export{e as data};
