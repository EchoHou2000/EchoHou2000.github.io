const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":126,\"nextId\":126,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-184f4da6#未来的工程师开始启航\",\"2\":\"v-184f4da6#为什么选择了软件开发\",\"3\":\"v-184f4da6#未来的职业规划\",\"4\":\"v-184f4da6#我的火星船票\",\"5\":\"v-2e3eac9e\",\"6\":\"v-89e985c0\",\"7\":\"v-89e985c0#为什么选择消息队列\",\"8\":\"v-89e985c0#为什么选择rocketmq\",\"9\":\"v-89e985c0@0\",\"10\":\"v-89e985c0@1\",\"11\":\"v-7678d6ed\",\"12\":\"v-7678d6ed@0\",\"13\":\"v-65df3dd6\",\"14\":\"v-65df3dd6@0\",\"15\":\"v-65df3dd6@1\",\"16\":\"v-c5e5db88\",\"17\":\"v-c5e5db88@0\",\"18\":\"v-6d907f8c\",\"19\":\"v-6d907f8c#缓存击穿\",\"20\":\"v-6d907f8c#如何解决\",\"21\":\"v-6d907f8c#缓存穿透\",\"22\":\"v-6d907f8c#如何解决-1\",\"23\":\"v-6d907f8c@0\",\"24\":\"v-6d907f8c@1\",\"25\":\"v-bec7415e\",\"26\":\"v-bec7415e#业务需求\",\"27\":\"v-bec7415e#为什么不用http协议\",\"28\":\"v-bec7415e#websocket好在哪里\",\"29\":\"v-bec7415e@0\",\"30\":\"v-bec7415e@1\",\"31\":\"v-e9172ae6\",\"32\":\"v-e9172ae6#原子性\",\"33\":\"v-e9172ae6#一致性\",\"34\":\"v-e9172ae6#隔离性\",\"35\":\"v-e9172ae6#持久性\",\"36\":\"v-e9172ae6@0\",\"37\":\"v-e9172ae6@1\",\"38\":\"v-41965b0b\",\"39\":\"v-41965b0b#应用层\",\"40\":\"v-41965b0b#以http协议举例\",\"41\":\"v-41965b0b#http协议和https的区别是什么\",\"42\":\"v-41965b0b#传输层\",\"43\":\"v-41965b0b#网络层\",\"44\":\"v-41965b0b#网络接口层\",\"45\":\"v-41965b0b@0\",\"46\":\"v-41965b0b@1\",\"47\":\"v-1d94f08f\",\"48\":\"v-1d94f08f#业务需求\",\"49\":\"v-1d94f08f#思路\",\"50\":\"v-1d94f08f#代码实现\",\"51\":\"v-1d94f08f#一、声明注解\",\"52\":\"v-1d94f08f#二、定义切面。\",\"53\":\"v-1d94f08f#三、应用注解\",\"54\":\"v-1d94f08f#spring-aop的实现原理\",\"55\":\"v-1d94f08f@0\",\"56\":\"v-1d94f08f@1\",\"57\":\"v-ea3cc312\",\"58\":\"v-ea3cc312@0\",\"59\":\"v-ea3cc312@1\",\"60\":\"v-6c236ae4\",\"61\":\"v-6c236ae4#概念\",\"62\":\"v-6c236ae4#api\",\"63\":\"v-6c236ae4@0\",\"64\":\"v-6c236ae4@1\",\"65\":\"v-2f61cc63\",\"66\":\"v-2f61cc63#put方法内部的执行流程\",\"67\":\"v-2f61cc63#hashmap的底层存储\",\"68\":\"v-2f61cc63#扩容机制\",\"69\":\"v-2f61cc63@0\",\"70\":\"v-2f61cc63@1\",\"71\":\"v-37c48da6\",\"72\":\"v-37c48da6#题目\",\"73\":\"v-37c48da6#思路\",\"74\":\"v-37c48da6@0\",\"75\":\"v-37c48da6@1\",\"76\":\"v-345adc68\",\"77\":\"v-345adc68#题目\",\"78\":\"v-345adc68#思路\",\"79\":\"v-345adc68@0\",\"80\":\"v-345adc68@1\",\"81\":\"v-30f12b2a\",\"82\":\"v-30f12b2a#题目\",\"83\":\"v-30f12b2a#思路\",\"84\":\"v-30f12b2a#代码\",\"85\":\"v-30f12b2a@0\",\"86\":\"v-30f12b2a@1\",\"87\":\"v-311d62c8\",\"88\":\"v-311d62c8#思路\",\"89\":\"v-311d62c8@0\",\"90\":\"v-311d62c8@1\",\"91\":\"v-2d8779ec\",\"92\":\"v-2d8779ec#题目\",\"93\":\"v-2d8779ec#思路\",\"94\":\"v-2d8779ec@0\",\"95\":\"v-2d8779ec@1\",\"96\":\"v-3f8407b5\",\"97\":\"v-3f8407b5#思路\",\"98\":\"v-3f8407b5@0\",\"99\":\"v-3f8407b5@1\",\"100\":\"v-6098439e\",\"101\":\"v-6098439e#思路\",\"102\":\"v-6098439e@0\",\"103\":\"v-6098439e@1\",\"104\":\"v-3c296f58\",\"105\":\"v-3c296f58@0\",\"106\":\"v-3c296f58@1\",\"107\":\"v-242c0073\",\"108\":\"v-242c0073#思路\",\"109\":\"v-242c0073@0\",\"110\":\"v-242c0073@1\",\"111\":\"v-1f2db491\",\"112\":\"v-1f2db491#思路\",\"113\":\"v-1f2db491@0\",\"114\":\"v-1f2db491@1\",\"115\":\"v-1e8f6593\",\"116\":\"v-1e8f6593#思路\",\"117\":\"v-1e8f6593@0\",\"118\":\"v-1e8f6593@1\",\"119\":\"v-0d4e2de0\",\"120\":\"v-0d4e2de0#思路\",\"121\":\"v-0d4e2de0@0\",\"122\":\"v-0d4e2de0@1\",\"123\":\"v-e1e3da16\",\"124\":\"v-07412858\",\"125\":\"v-afd8dcb6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,53],\"1\":[1,37],\"2\":[1,46],\"3\":[1,60],\"4\":[1,9],\"5\":[1],\"6\":[2],\"7\":[1,72],\"8\":[1,20],\"9\":[null,null,1],\"10\":[null,null,2],\"11\":[3,14],\"12\":[null,null,1],\"13\":[1,18],\"14\":[null,null,1],\"15\":[null,null,1],\"16\":[1,30],\"17\":[null,null,1],\"18\":[1,15],\"19\":[1,9],\"20\":[1,13],\"21\":[1,12],\"22\":[1,31],\"23\":[null,null,1],\"24\":[null,null,2],\"25\":[1],\"26\":[1,11],\"27\":[1,23],\"28\":[1,28],\"29\":[null,null,1],\"30\":[null,null,3],\"31\":[1,6],\"32\":[1,20],\"33\":[1,9],\"34\":[1,4],\"35\":[1,5],\"36\":[null,null,1],\"37\":[null,null,1],\"38\":[2,7],\"39\":[1,9],\"40\":[1,26],\"41\":[1,26],\"42\":[1,9],\"43\":[1,13],\"44\":[1,8],\"45\":[null,null,1],\"46\":[null,null,1],\"47\":[3],\"48\":[1,9],\"49\":[1,28],\"50\":[1,7],\"51\":[2,27],\"52\":[3,39],\"53\":[2,23],\"54\":[2,31],\"55\":[null,null,1],\"56\":[null,null,1],\"57\":[1,21],\"58\":[null,null,1],\"59\":[null,null,1],\"60\":[1,18],\"61\":[1,11],\"62\":[1,30],\"63\":[null,null,1],\"64\":[null,null,1],\"65\":[1,21],\"66\":[1,26],\"67\":[1,16],\"68\":[1,9],\"69\":[null,null,1],\"70\":[null,null,1],\"71\":[2],\"72\":[1,11],\"73\":[1,50],\"74\":[null,null,2],\"75\":[null,null,2],\"76\":[2],\"77\":[1,10],\"78\":[1,73],\"79\":[null,null,2],\"80\":[null,null,2],\"81\":[2],\"82\":[1,17],\"83\":[1,14],\"84\":[1,26],\"85\":[null,null,2],\"86\":[null,null,1],\"87\":[2,23],\"88\":[1,53],\"89\":[null,null,1],\"90\":[null,null,1],\"91\":[2],\"92\":[1,17],\"93\":[1,60],\"94\":[null,null,1],\"95\":[null,null,1],\"96\":[2,13],\"97\":[1,48],\"98\":[null,null,1],\"99\":[null,null,1],\"100\":[2,22],\"101\":[1,39],\"102\":[null,null,1],\"103\":[null,null,1],\"104\":[2,74],\"105\":[null,null,1],\"106\":[null,null,2],\"107\":[2,35],\"108\":[1,32],\"109\":[null,null,1],\"110\":[null,null,1],\"111\":[2,31],\"112\":[1,33],\"113\":[null,null,2],\"114\":[null,null,2],\"115\":[2,32],\"116\":[1,54],\"117\":[null,null,2],\"118\":[null,null,1],\"119\":[2,16],\"120\":[1,40],\"121\":[null,null,1],\"122\":[null,null,1],\"123\":[1],\"124\":[1],\"125\":[1]},\"averageFieldLength\":[1.287049316250946,27.125670761229188,0.8509109518495673],\"storedFields\":{\"0\":{\"h\":\"😎About Me\",\"t\":[\"谈不上走了很多的路，吃了很多的苦，但是还是想要把我的故事记录下来，提醒自己：回头看看路，不要忘了16岁自己的梦想；继续向前走，虚心请教也不要忘了关注自己的内心；观察身边的榜样，但是不要盲目\\\"模仿别人\\\"而\\\"成为别人\\\"，记住做自己。\",\"博学而笃志，切问而近思。\",\"最近在找日常实习的时候，有个面试官问了一个问题，我为什么选择了计算机，又为什么选择了Java后端？我的职业规划是怎样的？\",\"中学时代，我一直都是个很热血的人，初中立志要上我们当地最好的高中，有多励志呢？借着一次上台发言的机会，我拿着话筒大声告诉台下所有的师生我的梦想，以至于在其他教学楼上课的学生都听到了。这是我第一次告诉大家我的梦想。\",\"那个颤抖得几乎都要哭出来却又很坚定的声音和一往无前的气势，作为一个瘦弱的女生，我现在回想起来都感到无比的震撼和感动。 大家都知道我的梦想，哪怕很简单，就是上本地最好的高中，但是都会有意无意、时不时地帮助我，我最后真的上了那所高中，作为一个天资愚笨的学生，离不开长期的努力，也离不开那天\\\"发疯般\\\"地触动心灵地大喊。大家都知道了我的梦想和决心，我也知道了自己的愿望有多强烈。\",\"当我大声说出梦想的时候，全世界都在给我让路。\",\"这是我初中印象最深刻的一刻，让我知道了梦想的力量，学会了追逐梦想。真正和我现在的职业规划搭上关系，要从高中二年级开始。\"]},\"1\":{\"h\":\"未来的工程师开始启航\",\"t\":[\"高中二年级时，有一件令我印象很深刻，也令我很愤怒的事，就是\\\"孟晚舟事件\\\"，加拿大非法拘禁华为创始人任正非的女儿，实际上是美国对华为的制裁和警告。从高中二年级一直到报考专业，我的目标就是立志进入中国的科技行业，我要做中国自己的芯片，打败美国，我要学信息与通信工程这样的专业。同样也是，一提到我的梦想，我就两眼发光，一点都不惧怕跟别人说出我的这个看起来\\\"假大空\\\"的梦想。\",\"虽然高考成绩自己并不满意，对物理也并不擅长，但是我还是选择了自动化专业。被录取这个专业后，一直到第一学期，我都通过知乎、家长、老师等等渠道了解这个专业的就业方向，也去学院的实验室开始尝试焊电路板，一直不断地探索。虽然后来发现，即使对芯片很热爱，也觉得对社会有很深远的意义，但我对物理是真的不擅长，甚至有点儿痛苦，但是我喜欢程序世界。既然底层电路这些我做不来，那就试试软件嘛。\"]},\"2\":{\"h\":\"为什么选择了软件开发\",\"t\":[\"虽然我也并不确定我转到软件方向，就一定能做好，但我想试试，至少我确定了我不擅长硬件，为什么不向其他领域探索呢，如果我能在其他领域做出对这个世界有积极意义的产品，不也一样很好吗?\",\"事实是，我真的做到了！\",\"这就是我转入计算机专业的原因，因为我想探索出自己擅长的、对社会有积极意义的、自己热爱的。虽然一开始学C语言的时候确实很痛苦，但是看到它运行起来的那一刻，觉得很满足，觉得自己好像找到和自己灵魂相通的方向了一样，虽然不是那么容易，但是自己确实是能够做好的，无非是一遍两遍三遍四遍不停地去看、去思考为什么、去模仿、去自己造而已。\",\"我为什么选择了Java，很简单。一是Java的学习路线很友好，能够很快给人以正反馈，这也许也是让我觉得自己热爱的原因之一，二是Java也确实很流行，很多公司都有Java相关的岗位，让我觉得我真的能用Java做出对社会有积极意义的产品，三，其实选择什么语言没那么重要，Java或许不会永远流行，就像PHP一样，社会和公司的业务是不断变化的，要做好转语言的准备，一个优秀的工程师也不应该不看具体业务场景去死抠一门语言，做出好的产品，要思考，也要应该重视底层原理，原理学好了，语言之间的转换也不难。\",\"最近也想了想自己想加入什么样的团队，以及上份实习为什么离职。\"]},\"3\":{\"h\":\"未来的职业规划\",\"t\":[\"至于长远的职业发展，我是一直打算在后端这个领域深耕的，做出对社会有积极意义的产品，争取拿到领域内的NO.1吧哈哈。\",\"1-2年内，我会持续关注自己的基础能力，比如数据库、计算机网络、Java基础，也包括消息队列和设计模式，代码背后为什么用这个数据类型而不是其他呢，会出现什么问题。\",\"这个过程中，也会一直理解负责产品的业务，比如这个模块为什么这么设计，受众是谁，哪个模块最有用，依赖的上游有没有一些潜在的问题，自己能不能尝试改一改去保证更高的质量，能否让自己的工作变得challenging。\",\"工作半年之后，自己要做到对于业务有足够多的理解，能够根据需求去独立完成有意义的模块。\",\"当然除了基础能力、业务理解能力、产品意识，针对不断变化的业务场景和数据量，可能还需要掌握其他知识，比如可能会转Golang，可能会上云，可能要用到大数据和人工智能来解决瓶颈。这些都是需要在工作中不断思考，不断反思，学习对工作最有用的技术，把产品做好。\",\"工作1-2年之后，除了基础的增删改查，结合工作实际负责的业务或者兴趣，自己需要对后端的某个特定领域有一定程序的深挖和积累，比如数据库、中间件、网络编程。\",\"如果时间可以倒流，我会回到中学时代，对自己说，你好，谢谢你的梦想，支撑着我前进，大家都说你努力，很多人也夸你优秀，我也觉得你超级优秀😉虽然这一路走得并不顺利，也有很多次迷茫，觉得自己被否定，但是一切都在向好的方向发展，20岁的我没有让你失望，也没有忘记我们的梦想👍你我各自努力，最高处见！！！\"]},\"4\":{\"h\":\"我的火星船票\",\"t\":[\"NASA 星球科学总监 Jim Green 表示，把自己姓名发送到火星上，也是参与火星以及未来太空探险旅行的一种方式。\",\"Forever Young\"]},\"5\":{\"h\":\"幻灯片页\"},\"6\":{\"h\":\"我在弹幕推送系统中为什么用RocketMQ?\"},\"7\":{\"h\":\"为什么选择消息队列\",\"t\":[\"在学校的软件实验室接过一个项目，是一个商业性的视频弹幕系统，对性能有一定的要求，我负责做视频上传存储、点赞关注和弹幕推送等功能。\",\"因为考虑到大存储量和用户量，选择了FastDFS分布式文件存储，并且技术设计上配合前端采用分片上传、使用Redis来断点续传和秒传。\",\"关注和弹幕推送选择了消息队列来实现，主要考虑有以下几点：\",\"消息队列的发布-订阅模式。如果是传统的队列模式，一个队列中，一个生产者对应一个消费者，但是如果一个生产者对应多个消费者（就像关注功能，一个被关注者对应多个关注者），可能要复制队列，这对资源是一种损耗。所以为了更好地实现关注功能，是选择消息队列的一个重要原因，因为消息队列的机制，在RocketMQ中有\\\"主题\\\"的概念，生产者可以将消息推送到这个主题中，多个消费者可以订阅这个主题进行消费。\",\"消息队列的异步和削峰。最为明显的是弹幕推送功能，比如我们点开一个视频，系统会将关于这个视频的所有弹幕，推送给所有正在观看的用户，而发送一条弹幕后，首先会请求服务器存入数据库中，又会从数据库中查询出所有的弹幕，推送给所有用户。一次前端请求，对于后端数据库是两次的IO处理，如果是大用户量，后端承受的压力更大。所以采用消息队列，我们一可以异步（不至于发生阻塞让用户长时间等待）、二又可以削峰（消息队列尽可能来处理，可以处理得慢一点，但是不能把服务器打挂）。\",\"消息队列的解耦。消息队列主要用于消息的传输和通信，比如关注功能会用到这个用户的信息，弹幕推送也会用到用户的消息，未来可能还会开发视频推送功能，也会用到消息。如果我们把这些功能都写到一个模块中，增加和减少功能，代码都要改不少处。所以我们可以用消息队列把消息模块解耦出来，比如关注完，将信息存入消息队列后就直接返回，不管弹幕推送和视频推送怎样处理，这是\\\"下游\\\"的事儿。\",\"这是为什么采用消息队列的思考。主流的消息队列有很多，比如RabbitMQ、RocketMQ、Kafka等，为什么我用了RocketMQ呢？\"]},\"8\":{\"h\":\"为什么选择RocketMQ\",\"t\":[\"我最看中的一点是RocketMQ是从阿里内部开源的产品，也是Apache的顶级开源项目。历经淘宝、天猫双十一流量高峰的考验，可靠性也很强，所以商业化、高并发、互联网、金融的项目，用RocketMQ是完全可以的。\",\"RabbitMQ的性能也还行（但是吞吐量比RocketMQ和Kafka低一个数量级），但是RabbitMQ是基于Erlang开发的，不利于做二次开发和维护，但是Erlang语言本身有并发的优势，如果数据量不大，小公司可以优先采用RabbitMQ。\",\"Kafka更适合大数据领域的实时计算和日志采集，但是有一点劣势是消息可能会重复消费。\"]},\"9\":{\"c\":[\"项目设计\"]},\"10\":{\"c\":[\"MQ\",\"技术选型\"]},\"11\":{\"h\":\"VO、DTO、Entity的区别\",\"t\":[\"Entity是实体类，对应数据库表中的字段和属性。\",\"DTO是数据传输对象，对应实际需要传输的字段，是用来将Entity转换为VO（或者VO转化为Entity）过程中需要的中间对象，因为不是所有的接口，都需要数据库表中的所有字段，如果用Entity会造成资源的消耗，也会有安全问题。\",\"VO是对应前端的HTML，有一部分字段后端数据库表是没有的。\"]},\"12\":{\"c\":[\"项目规范\"]},\"13\":{\"h\":\"double类型的值可以赋给long变量吗\",\"t\":[\"在不进行强制转换的情况下，double类型的值可以赋给long变量吗？\",\"不可以。即使double类型的值是1，这个值也不能赋给long变量。\",\"比如下面这两种写法，都是错的，编译器会报错：\",\"double a = 0.1 long b = a; // 编译报错 long b = 0.1; // 编译报错 \",\"double a = 1; long b = a; // 编译报错 long b = 1; // 这个可以 \"]},\"14\":{\"c\":[\"Java基础\"]},\"15\":{\"c\":[\"基础语法\"]},\"16\":{\"h\":\"Git的rebase\",\"t\":[\"如果此时有两个分支，一个master分支，一个feature分支（需求开发分支），feature是从master的某个节点处分离出来的一条分支。\",\"如果我们在feature分支开发一段时间后，想拉取master分支的最新代码合并到feature上，可以用git pull --rebase。feature是待变基分支，master是基分支。\",\"比如说feature是master节点B处拉出来的一条新分支，在feature分支开发一段时间后（此时是A->B->C->D），要拉取master最新的代码合到feature上（比如master分支上在B节点后新开发了M）。这时候需要把feature上的提交暂存下来，然后删掉feature的提交记录，找到master的最新记录，再把暂存的feature提交接上去。\",\"所以显而易见，使用git pull --rebase，会使feature的原基底都变了，会丢掉一部分之前的提交记录，有时候不好追溯之前的提交。\"]},\"17\":{\"c\":[\"Git\"]},\"18\":{\"h\":\"缓存击穿和缓存穿透如何解决\",\"t\":[\"当数据量达到一定数量级后，对于用户经常访问的数据（热点数据）或者构建比较复杂的数据，只用MySQL进行查询是比较耗时的，所以我们用Redis进行缓存，因为是基于内存的数据库，所以查询很快。\",\"但是使用缓存又会产生一些问题，比如缓存雪崩、缓存击穿、缓存穿透。\",\"今天来重点讲一下缓存击穿和缓存穿透（滴滴面试题）。\"]},\"19\":{\"h\":\"缓存击穿\",\"t\":[\"当Web应用触发请求，到Redis读取数据，而此时热点数据缓存过期，缓存无法命中，就去数据库中请求数据，这一瞬间大量请求就会打到数据库，数据库压力过大，可能会有宕机的风险。\"]},\"20\":{\"h\":\"如何解决\",\"t\":[\"缓存击穿的原因就是热点数据缓存过期，那么其中一个解决方案就是：不给热点数据设置过期时间，由后台异步更新缓存，或者当热点数据快要过期的时候，提前通知后台线程更新缓存以及重新设置更新时间。\",\"还有一个点就是缓存无法命中的场景，可以设置互斥锁，保证同一时间只有一个用户线程更新缓存，未能获取互斥锁的请求，要么返回空值或者默认值，要么等待锁释放后重新读取缓存。\"]},\"21\":{\"h\":\"缓存穿透\",\"t\":[\"当Web应用触发请求，到Redis读取数据，而此时缓存中没有数据，缓存无法命中，就去数据库中请求数据，而数据库中也没有数据，就无法构建缓存。这时候大量请求又请求数据库，而数据库没有对应的资源，数据库承受巨大压力，有宕机的风险。\"]},\"22\":{\"h\":\"如何解决\",\"t\":[\"这种现象的原因就是：数据库中没有Web应用要请求的数据。\",\"一、可能是恶意请求，数据压根就不存在。我们可以在接口层面，对于一些非法的请求进行拦截判断，也就不会到达数据库了。\",\"二、缓存空值或默认值。当线上发现发生缓存穿透的问题，我们可以针对请求，在Redis里缓存一个空值或者默认值，会直接返回给前端，而不会请求数据库。\",\"三、布隆过滤器。在向数据库写入数据的时候，在布隆过滤器上做个标记，在Web应用请求查询的时候，先查布隆，如果不存在就直接返回，如果存在再向缓存中查询数据。但是可能有精度问题，因为布隆过滤器底层是由位图数组和哈希算法实现的，可能会存在哈希碰撞的问题，如果布隆判断不存在，就一定不存在，但是如果判断存在，实际上可能不存在。\"]},\"23\":{\"c\":[\"Redis\"]},\"24\":{\"c\":[\"面试高频\",\"缓存\"]},\"25\":{\"h\":\"为什么用WebSocket协议而不是HTTP\"},\"26\":{\"h\":\"业务需求\",\"t\":[\"业务背景是一个类似于B站的视频弹幕系统，现在需要实现一个用户发送弹幕和获取弹幕（推送弹幕）功能。\",\"场景是这样的，用户进入我们的系统，在视频列表点进自己感兴趣的视频，然后看到了视频上方的弹幕，自己也可以发送一条弹幕，这条弹幕也会推送到所有在线看到视频的用户。\"]},\"27\":{\"h\":\"为什么不用HTTP协议\",\"t\":[\"如果我们采用传统的HTTP协议，效果如何？\",\"HTTP协议是短连接，并且是单向的，也就是说，客户端需要不停地轮询服务端：\\\"你那有没有资源？\\\"，如果有，会进行一个拉取资源的操作，而服务端并不会主动向客户端推送资源。\",\"这就是短连接的过程，建立连接和释放连接的过程也是要消耗资源的。\",\"TCP三次握手建立连接 拉取资源 TCP四次挥手释放连接 ...... TCP三次握手建立连接 拉取资源 TCP四次挥手释放连接 \",\"但是，如果服务器此时就没有新增的资源，客户端还是要不断轮询，这又是对资源的浪费。\",\"所以，对于获取弹幕功能，我们没有采用HTTP协议。\"]},\"28\":{\"h\":\"WebSocket好在哪里\",\"t\":[\"那么WebSocket协议对比HTTP协议的优势在哪呢，最后我们为什么采用WebSocket协议？\",\"对于弹幕模块，有两个很大的优势。\",\"一是全双工通信，也就是不但客户端能向服务端请求资源，服务端也能向客户端推送资源。\",\"二是长连接，也就是不用频繁请求、断开连接消耗资源，并且弹幕模块本来就是一个长时间请求弹幕的过程，用长连接更适合，并且也是基于TCP协议的，能够保证消息的可靠性。\",\"除此之外，WebSocket协议没有HTTP协议的请求头header，也就是传输的报文体积更小，消息速度更快。\",\"但是并不是说WebSocket协议就一定优于HTTP协议，HTTP协议协议虽然多了个请求头header，但是易于拓展，并且如果是不需要长时间通信的功能或者接口，用HTTP的短连接更好，用WebSocket的长连接反而会长时间占用内存这些资源。所以用什么技术，架构如何设计，是需要根据具体业务场景来判断的。\"]},\"29\":{\"c\":[\"计算机网络\"]},\"30\":{\"c\":[\"WebSocket\",\"项目\",\"原创\"]},\"31\":{\"h\":\"事务的ACID\",\"t\":[\"事务有四大特性。一致性是最终达成的目的，原子性、隔离性、持久性是手段。\"]},\"32\":{\"h\":\"原子性\",\"t\":[\"一个事务中的所有操作，要么全部发生，要么全部不发生，不会出现只执行一半，而另一半没有执行的情况。\",\"比如经典的转账案例，A向B转账100元，操作1是A的账户扣除100元，操作2应该是B的账户增加100元。但是如果操作1结束后的瞬间，数据库宕机，操作2没有发生，整个事务应该回滚，回到操作1之前的状态，就像任何操作没有进行的样子，而不能\\\"明明A账户扣除了100元，但是B账户没有增加\\\"的情况。\"]},\"33\":{\"h\":\"一致性\",\"t\":[\"一个事务执行前后，数据库应该保持一致性的状态，比如A账户和B账户原来余额都是200元，一共是400元，转账之后，A账户应该是100元，B账户应该是300元，加起来还是400元。\"]},\"34\":{\"h\":\"隔离性\",\"t\":[\"数据库的事务应该具有隔离性，即不同事务在不同的空间能够并发执行，而不会相互干扰。\"]},\"35\":{\"h\":\"持久性\",\"t\":[\"一个事务执行完毕后，对数据库的影响应该是永久的，即使数据库发生宕机，也不应该丢失数据。\"]},\"36\":{\"c\":[\"数据库\"]},\"37\":{\"c\":[\"重要\"]},\"38\":{\"h\":\"TCP/IP四层模型\",\"t\":[\"TCP/IP四层模型是计算机网络实际应用的模型。 从上到下分别是应用层、传输层、网络层、网络接口层。\"]},\"39\":{\"h\":\"应用层\",\"t\":[\"应用层是用户直接接触到的最上层，比如手机上的软件都是在应用层实现的。\",\"应用层只需要专注为用户提供服务，比如HTTP超文本传输协议、SMTP简单邮件传输协议、FTP文件传输协议、DNS域名解析服务、Telnet远程登陆协议等。\"]},\"40\":{\"h\":\"以HTTP协议举例\",\"t\":[\"这些协议在应用层专注为用户提供协议，比如我们打开一个网页，就是HTTP的GET请求，通常会在浏览器的搜索框携带一些参数，HTTP本身是不会对url的长度进行限制，但是浏览器的本身会进行限制，并且GET请求的参数只允许有ASCII码。我们看到的网页，比如HTML就是一个常见的超文本，标签里包含了一些超链接、视频、图片，经浏览器解析后，我们看见的页面就是既包含文本，又包含视频等。\",\"除了GET请求，HTTP还有一个POST请求，GET请求代表获取某个资源，POST请求代表添加某个资源，浏览器对Body的大小没有限制，格式也只需要前后端协商好即可。比如为某篇文章添加评论，提交后文本会写到报文Body中，以Body的形式通过TCP协议存到服务器中。\",\"应用数据从应用层传到传输层。\"]},\"41\":{\"h\":\"HTTP协议和HTTPS的区别是什么\",\"t\":[\"两个字：安全！\",\"如何保证安全的呢。一是SSL/TLS安全协议用来加密，二是向CA申请数字证书。\",\"HTTP是超文本传输协议，在三次握手之后就直接传输数据，数据是以明文的形式传输，不安全，容易被被篡改，而HTTPS协议是引入了SSL/TLS安全协议，使得报文能够加密传输。在四次握手之后还要进行SSL/TLS的握手过程，才可进入加密报文传输。\",\"并且HTTPS需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。\",\"除此之外，默认端口也不一样，HTTP协议默认端口是80，HTTPS默认端口是443。\"]},\"42\":{\"h\":\"传输层\",\"t\":[\"传输层为上层（也就是应用层）提供网络支持，该层有两个传输协议，用户数据报协议UDP、传输控制协议TCP。 传输数据从应用层传到传输层之后，会加上TCP的头部传输给网络层。\"]},\"43\":{\"h\":\"网络层\",\"t\":[\"因为网络之间的传输过程是错综复杂的，我们分层就是为了让每一层简单、高效。网络之间实际的传输功能是由网络层实现的，传输层只负责服务好应用，作为数据传输的媒介，帮助实现通信。 网络层提供了IP协议，实现主机与主机之间通信，也可以叫点对点的通信，当传输数据+TCP头部传到网络层时，会加上一个IP头部传送给下一层。\"]},\"44\":{\"h\":\"网络接口层\",\"t\":[\"提供了数据链路级别的功能，当传输数据+TCP头+IP头传输到网络接口层时，会在前后分别加上帧头和帧尾，封装成数据帧发送到网络上。\",\"该层的传输协议有点对点协议PPP（数据链路层），用来将网络层传输的数据包封装成帧。\"]},\"45\":{\"c\":[\"计算机网络\"]},\"46\":{\"c\":[\"分层模型\"]},\"47\":{\"h\":\"我是怎么用Spring AOP的？\"},\"48\":{\"h\":\"业务需求\",\"t\":[\"项目中需要对前端的元素、接口进行权限控制，如果权限不足，无法访问。而后端又有很多接口需要进行权限判断，每个接口都进行判断，会有很多重复性的代码，可维护性不高。\"]},\"49\":{\"h\":\"思路\",\"t\":[\"所以我们需要把这些公共的代码抽出来，我们编写业务代码的时候，只需要关注具体不同的逻辑即可，不用写大量重复性的代码。而具体的业务逻辑相当于一个\\\"织入\\\"进去的操作。\",\"在这个过程中，我们抽出来不是关键业务的同一类方法，并且封装成一个类用来判断权限。\",\"Spring AOP就是在某些方法前后执行一些通用的操作，而这些操作又不会影响程序本身的正常执行，比如日志操作、权限判断。\",\"我们可以使用Spring AOP的技术来实现，在AOP中，这个封装成的类，叫切面，可以用@Aspect实现。我们在调用每一个接口的时候，都需要先判断权限，所以给切面中具体的类加上@Before注解，代表在目标方法调用之前执行。\"]},\"50\":{\"h\":\"代码实现\",\"t\":[\"我们希望最后的实现效果，是在Controller层的接口直接加上一个注解，就能实现权限判断，这个注解是我们自定义的，而这个注解如何工作的具体逻辑，需要在切面里写。\"]},\"51\":{\"h\":\"一、声明注解\",\"t\":[\"我们想对角色权限进行控制，第一步就是先定义自己的注解，确定这个注解的位置后，切面才能工作。\",\"/** * @Retention 代表生命周期，这里是RUNTIME，表示运行期间一直存在 * @Target 表示这个注解要加在方法上 * @Document 表示这个注解会被加到Doc文档上 * @Component 表示会被Spring进行管理，后面进行依赖注入 */ @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) @Documented @Component public @interface ApiLimitedRole { String[] limitedRoleCodeList() default {}; } \"]},\"52\":{\"h\":\"二、定义切面。\",\"t\":[\"@Order(1) @Component @Aspect public class ApiLimitedRoleAspect { @Autowired private UserSupport userSupport; @Autowired private UserRoleService userRoleService; // @Pointcut 表示切点的应用范围 // 这里指发挥作用的注解具体是哪一个 // 即使check为空，也仍要写切点，因为不写切点，程序就无法被AOP代理，不知道应用范围 @Pointcut(\\\"@annotation(com.houbingzhi.bilibili.domain.annotation.ApiLimitedRole)\\\") public void check(){ } // 在调用Controller层时的接口时，会先进行下面这些权限判断 // 再进行具体的业务逻辑 @Before(\\\"check() && @annotation(apiLimitedRole)\\\") public void doBefore(JoinPoint joinPoint, ApiLimitedRole apiLimitedRole){ // 通用的判断权限的业务逻辑 // ...... } } \"]},\"53\":{\"h\":\"三、应用注解\",\"t\":[\"@ApiLimitedRole(limitedRoleCodeList = {AuthRoleConstant.ROLE_LV0}) @DataLimited @PostMapping(\\\"/user-moments\\\") public JsonResponse<String> addUserMoments(@RequestBody UserMoment userMoment) throws Exception { // 具体的业务逻辑 // ...... return JsonResponse.success(); } \"]},\"54\":{\"h\":\"Spring AOP的实现原理\",\"t\":[\"Spring这个优秀的框架中，有很多设计模式的体现，比如单例模式，再比如AOP机制也应用了代理模式。\",\"那么是如何应用代理模式的呢？\",\"我们最前面定义注解的时候，在注解最上面用了一个@Component让Spring进行管理，这个我们自己定义的注解就成了Spring管理的一个Bean对象，然后我们为这个对象配置了一个切面。那么Spring在创建这个Bean的时候，实际上创建的是这个Bean的代理对象，后续对Bean中方法的调用，实际上是代理类重写的代理方法。\",\"AOP使用的是两种动态代理，一种是JDK的动态代理，一种是CGLib的动态代理。\",\"那么什么是动态代理？什么是静态代理？\",\"动态代理比静态代理更加灵活，动态代理只需要实现接口即可，而对于静态代理，如果接口中的方法变了，目标对象和代理对象都要进行修改。\",\"再说这两种动态代理方法有什么区别？\",\"如果被代理的类有实现的接口，那就是JDK代理类；如果没有实现接口，是继承实现的，那就是CGLib动态代理类。\"]},\"55\":{\"c\":[\"Web开发\"]},\"56\":{\"c\":[\"Spring\"]},\"57\":{\"h\":\"抽象类和接口的区别是什么\",\"t\":[\"抽象类的声明是abstract class 类名，接口的声明是public interface 接口名。\",\"一个类只能继承一个抽象类，但是能实现多个接口。\",\"接口主要是对类的行为进行约束，一个类实现某个接口也就拥有了对应的行为。抽象类主要用于代码复用，强调所属关系，比如从类名上可以看出所属关系。\",\"接口中的成员变量只能是public static final类型的，并且要有初始值，不能被修改。抽象类中的成员变量默认default，并且可以被重新赋值和修改。\"]},\"58\":{\"c\":[\"Java基础\"]},\"59\":{\"c\":[\"重要\"]},\"60\":{\"h\":\"掌握Java反射\",\"t\":[\"我们在业务开发中，为一个类设置属性，最常见的是这样的。\",\"User user = new User(); user.setName(\\\"Feifei\\\"); \",\"在这种情况下，初始化一个类之前我们已经知道这是一个什么类了，直接调用构造方法类即可。\",\"但是这是在我们一开始，就知道这是一个什么样的类的前提下，如果我们不知道这是一个什么样的类，也就没法直接new一个对象来调用构造方法了。这其实就是反射的特点。\"]},\"61\":{\"h\":\"概念\",\"t\":[\"通过反射，能够在运行时分析类以及执行类中方法，可以获取一个类中所有的属性和方法，还可以调用这些属性和方法。\",\"应用场景比如Spring、Mybatis框架，底层原理都大量应用了反射机制。Spring AOP的JDK动态代理中，也应用了Method的API。\"]},\"62\":{\"h\":\"API\",\"t\":[\"// Class.forName 通过类的包名获取反射类 Class clazz = Class.forName(\\\"com.houbingzhi.s39.User\\\"); // 通过Class对象获取构造方法Construct对象 Constructor constructor = clazz.getConstructor(); // 通过Construct对象初始化反射类对象 Object object = constructor.newInstance(); // 获取要调用的方法的Method对象 Method setNameMethod = clazz.getMethod(\\\"setName\\\", String.class); Method getNameMethod = clazz.getMethod(\\\"getName\\\"); // 通过invoke方法执行 setNameMethod.invoke(object, \\\"Feifei\\\"); getNameMethod.invoke(object) \"]},\"63\":{\"c\":[\"Java基础\"]},\"64\":{\"c\":[\"重要\"]},\"65\":{\"h\":\"HashMap总结\",\"t\":[\"HashMap实现了Map接口，Map中的数据是以(Key,Value)的形式存储的，在查找的时候，能够通过哈希函数将Key映射到哈希表中的一个索引位置，从而实现快速访问。Key不能重复，但是Value可以重复。\",\"HashMap的键和值都可以为null，如果键为null，则映射到哈希表的第一个元素。\",\"HashMap有一个初始容量和负载因子，初始容量是哈希表的初始大小，默认是16，负载因子是哈希表在扩容之前，存储的键值对数量和哈希表大小的比例，默认是0.75。\"]},\"66\":{\"h\":\"put方法内部的执行流程\",\"t\":[\"在put元素的时候，背后调用了putVal方法，会先判断定位到的数组位置有没有元素。如果没有元素，则直接插入。如果有元素，会先判断Key是否相同，如果相同就直接覆盖；如果不同，就判断当前节点是否是一个树节点，如果是就调用putTreeVal将元素添加进去，如果不是就遍历链表插入（插入的是链表尾部）。\",\"那么是如何判断key是否相同的呢？\",\"简单来说，是先获取key对象的hashCode值，然后用hash方法将其低位和高位进行异或操作，得到最终的hash值，然后将hash值去模，映射到实际的存储位置上。对于hashCode的高位和低位，分布是比较均匀的，如果简单进行相加或与操作，容易出现哈希冲突，而异或操作可以避免这个问题。\"]},\"67\":{\"h\":\"HashMap的底层存储\",\"t\":[\"HashMap的底层是用数组实现的，当需要存储元素的时候，不断put元素进去，达到一定容量后会扩容，一是能存储的元素更多了，二是因为位置多了，查询效率也会更快，之前可能多个元素会通过拉链法放在同一个索引上，查询的时候还需要遍历链表，时间复杂度O(n)，如果位置多了，一个元素占一个索引，查找的时间复杂度就是O(1)。\"]},\"68\":{\"h\":\"扩容机制\",\"t\":[\"数组是无法自动进行扩容的，HashMap的resize()方法会声明一个更大容量的数组，将之前旧的小容量数组中的元素复制过去，并且重新计算hash值，计算hash值是为了将元素分布得更均匀，减少hash碰撞，这个计算hash值的过程是比较耗时的。\"]},\"69\":{\"c\":[\"Java基础\"]},\"70\":{\"c\":[\"HashMap\"]},\"71\":{\"h\":\"1.无重复字符的最长字串\"},\"72\":{\"h\":\"题目\",\"t\":[\"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\",\"输入：\\\"abc\\\" 输出：3 \",\"输入：\\\"ababc\\\" 输出：3 \"]},\"73\":{\"h\":\"思路\",\"t\":[\"本题有两个关键点，不含重复字符和最长子串。\",\"看到最长子串，可以想到滑动窗口，比如遍历\\\"ababc\\\"字符串，第一次碰到重复的字符a时，就计算这个字符下标之后的长度即\\\"abc\\\"，就像一个滑动的窗口，直到遇到再次重复的时候。\",\"字符串一共有128个ASCII码，可以声明一个数组，记录当前字符出现的上一次下标，如果没有出现过，默认为-1。\",\"并且start记录每个不重复字符串的初始位置，记录每个字符出现的下标，如果下次访问发现不为-1，说明出现过，start更新为这个下标的下一个。\",\"public int findLongest(String s){ int[] last = new int[128]; Arrays.fill(last,-1); int start = 0; int res = 0; for(int i = 0;i < s.length();i++){ int index = s.charAt(i); start = Math.max(start,last[index] + 1); res = Math.max(res,i-start+1); last[index] = i; } return res; } \"]},\"74\":{\"c\":[\"算法\",\"字符串\"]},\"75\":{\"c\":[\"滑动窗口\",\"已做4遍\"]},\"76\":{\"h\":\"2.反转链表\"},\"77\":{\"h\":\"题目\",\"t\":[\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \"]},\"78\":{\"h\":\"思路\",\"t\":[\"比如原链表是1->2->3->4->5->null，反转后应该是5->4->3->2->1->null。\",\"更清楚的：\",\"反转前：1->2->3->4->5->null 反转后：null<-1<-2<-3<-4<-5 \",\"我们注意到，节点具体的值和位置是不变的，变的只是指针和null值的位置。\",\"那么我们可以采用双指针的解法，一个pre指针指向head的前一位，用来反转后代表null值（null<-1<-2<-3<-4<-5）。\",\"一个cur指针从head开始往后遍历原链表，并且每遍历一个节点，指针要向前反转一次，直到遇到原链表的null值，此时pre值指向链表的最后一个节点，最后return pre即可。\",\"但是这个过程中有个问题，我们来模拟一下。一开始，pre指针指向null值，cur指针指向head节点，cur指针的next指针指向pre后，pre向后遍历，但是cur再向后遍历时候，发现指针已经没了(为了便于区分，...代表中间什么东西也没有，也就是无next指针，此时null<-1...2->3->4->5->null)，如何再向下一个遍历？\",\"我们可以定义个temp来临时保存cur的下一个指针即可，即temp=cur.next。这个temp是用来cur指针下一步遍历的。\",\" class ListNode{ int val; ListNode next; // 别忘了写构造方法 ListNode(){} ListNode(int val){ this.val = val; } ListNode(int val,ListNode next){ this.val = val; this.next = next; } } class Solution{ public ListNode reverse(ListNode head){ if(head == null){ return null; } ListNode pre = null; ListNode cur = head; while(cur != null){ ListNode temp = cur.next; // cur的next指针指向pre cur.next = pre; // pre移动到cur的位置 pre = cur; // cur指针往后走一步 cur = temp; } return pre; } } \"]},\"79\":{\"c\":[\"算法\",\"链表\"]},\"80\":{\"c\":[\"双指针\",\"已做7遍\"]},\"81\":{\"h\":\"3.二叉树的直径\"},\"82\":{\"h\":\"题目\",\"t\":[\"给你一棵二叉树的根节点，返回该树的最大直径。\",\"二叉树的直径是指两个节点之间的最大距离，不一定经过根节点。比如下面这颗树：\",\"输入：[1,2,3,4,5] 输出：3 解释：取路径[4,2,1,3]或者[5,2,1,3]的长度 \"]},\"83\":{\"h\":\"思路\",\"t\":[\"找到最大直径，其实就是维护一个最大值，这个最大值是，所有的节点的左子树和右子树之和中的最大值。因为二叉树本身就是一个递归的结构，所以我们可以递归遍历二叉树的每一个节点。\",\"那最大值怎么维护？\",\"如果当前节点的左右子树不为空，左右路径的大小即上一个节点的左右路径大小加一。\",\"上一个节点的左右路径大小怎么保存下来？\",\"遍历每一个节点时候，保存最大值时，同时返回当前节点的最大路径即可。\"]},\"84\":{\"h\":\"代码\",\"t\":[\"class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(){} TreeNode(int val){ this.val = val; } TreeNode(int val,TreeNode left,TreeNode right){ this.val = val; this.left = left; this.right = right; } } class Solution{ int max = 0; public int findMaxSize(TreeNode root){ if(root == null){ return 0; } dfs(root); return max; } private int dfs(TreeNode root){ if(root.left == null && root.right == null){ return 0; } int leftSize = root.left == null ? 0 : dfs(root.left) + 1; int rightSize = root.right == null ? 0 : dfs(root.right) + 1; max = Math.max(max,leftSize + rightSize); return Math.max(leftSize,rightSize); } } \"]},\"85\":{\"c\":[\"二叉树\",\"递归\"]},\"86\":{\"c\":[\"已做3遍\"]},\"87\":{\"h\":\"8.三数之和\",\"t\":[\"给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 。请找出所有和为 0 且 不重复 的三元组。\",\"输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] \",\"输入：nums = [0] 输出：[] \"]},\"88\":{\"h\":\"思路\",\"t\":[\"题目可以拆解成两个要求，一个是和为0的三元组，一个是不重复的三元组，但是三元组里面的数字是可以重复的。\",\"首先我们可以先把数字进行排序，如果三元组的第一个数字就是大于0的，那整个组肯定不满足要求，直接返回空的集合。\",\"如果不大于0，可以固定一个数字，用双指针寻找另外两个数字，一个在i+1处，一个在数组尾处，大于0就右指针向左移动，小于0就左指针向右移动。\",\"class Solution{ public List<List<Integer>> threeSum(int[] nums){ List<List<Integer>> res = new ArrayList<>(); if(nums == null || nums.length == 0){ return res; } Arrays.sort(nums); for(int i = 0;i < nums.length;i++){ if(nums[i] > 0){ return res; } if(i > 0 && nums[i] == nums[i-1]){ continue; } int l = i + 1; int r = nums.length-1; while(l < r){ if(nums[i] + nums[l] + nums[r] > 0){ r--; }else if(nums[i] + nums[l] + nums[r] < 0){ l++; }else{ res.add(Arrays.asList(nums[i],nums[l],nums[r])); // 去重逻辑 while(l < r && nums[r] == nums[r-1]){ r--; } while(l < r && nums[l] == nums[l+1]){ l++; } l++; r--; } } } return res; } } \"]},\"89\":{\"c\":[\"双指针\"]},\"90\":{\"c\":[\"中等\"]},\"91\":{\"h\":\"4.岛屿数量\"},\"92\":{\"h\":\"题目\",\"t\":[\"给你一个由'1'(陆地)和'0'(水)组成的二维网格，请你计算网格中的岛屿数量。\",\"岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\",\"此外，你可以假设该网格的四条边均被水包围。\",\"输入：grid = [ [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"], [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"] ] 输出：1 \"]},\"93\":{\"h\":\"思路\",\"t\":[\"首先，我们要在二维矩阵中找到第一个'1'出现的位置，这一步是毫无疑问的。那我们如何找到水平方向和竖直方向上是否有连接的陆地，并且统计岛屿数量呢？\",\"比如我们找到第一个'1'出现的位置后，可以向左搜索，看看为不为'1'，再回到原位，向右搜索，看看为不为'1'......这不就是DFS的算法吗，\\\"不到黄河不回头\\\"，可劲搜，直到走到头再回来继续朝另一个方向搜，发现为'0'，就跳出搜索。\",\"那知道怎么搜之后，岛屿数量是多少呢？下次搜如何避免重复统计呢？\",\"在dfs搜索之前，一旦遍历到一个'1'，就统计+1，因为dfs不论有没有搜到'1'，有没有连接多个'1'变成一个岛屿，最后都是一个岛屿，只不过是岛屿的大小而已。\",\"不难写出以下代码。\",\"public int findOnes(char[][] grid){ int res = 0; for(int i = 0;i < grid.length;i++){ for(int j = 0;j < grid[0].length;j++){ if(grid[i][j] == '1'){ res++; dfs(i,j,grid); } } } return res; } private void dfs(int i,int j,char[][] grid){ // 跳出搜索条件，注意边界条件 if(i < 0 || i > grid.length-1 || j < 0 || j > grid[0].length-1 || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(i+1,j,grid); dfs(i-1,j,grid); dfs(i,j+1,grid); dfs(i,j-1,grid); } \"]},\"94\":{\"c\":[\"DFS\"]},\"95\":{\"c\":[\"递归\"]},\"96\":{\"h\":\"12.二叉树的前序遍历\",\"t\":[\"给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\",\"输入：root = [1,null,2,3] 输出：[1,2,3] \"]},\"97\":{\"h\":\"思路\",\"t\":[\"用递归法很简单，用迭代法怎么实现？\",\"如果是层序遍历，一层一层遍历，适合用队列，刚好满足先进先出，先上层，后下层的顺序。\",\"如果是前中后序遍历，适合用栈来模拟。收集结果的时候，要注意收集结果的时机。在向栈中push元素的时候，要先push右子树，再push左子树，因为队列是先进后出，为了符合前序遍历的顺序。\",\"class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(){} TreeNode(int val){ this.val = val; } TreeNode(int val,TreeNode left,TreeNode right){ this.val = val; this.left = left; this.right = right; } } class Solution{ public List<Integer> preorderTraversal(TreeNode root){ List<Integer> res = new ArrayList<>(); if(root == null){ return res; } Stack<TreeNode> stack = new Stack<>(); stack.push(root); while(!stack.isEmpty()){ // 返回栈顶元素并出栈 TreeNode node = stack.pop(); res.add(node.val); if(node.right != null){ stack.push(node.right); } if(node.left != null){ stack.push(node.left); } } return res; } } \"]},\"98\":{\"c\":[\"二叉树\"]},\"99\":{\"c\":[\"迭代\"]},\"100\":{\"h\":\"9.两个数组的交集II\",\"t\":[\"给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] \",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] \",\"1 <= nums1.length, nums2.length <= 1000\"]},\"101\":{\"h\":\"思路\",\"t\":[\"寻找两个数组中相同的元素，可以先把两个数组进行排序，然后定义两个指针，分别指向两个数组，如果相同就把对应的元素收集起来，指针继续向后移动，如果不同就调整指针位置，继续判断。\",\"class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); List<Integer> list = new ArrayList<>(); for(int i = 0,j = 0;i < nums1.length && j < nums2.length;){ if(nums1[i] > nums2[j]){ j++; }else if(nums1[i] < nums2[j]){ i++; }else{ list.add(nums1[i]); i++; j++; } } int[] res = new int[list.size()]; for(int i = 0;i < list.size();i++){ res[i] = list.get(i); } return res; } } \"]},\"102\":{\"c\":[\"双指针\"]},\"103\":{\"c\":[\"简单\"]},\"104\":{\"h\":\"6.两数相加\",\"t\":[\"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\",\"请你将两个数相加，并以相同形式返回一个表示和的链表。\",\"你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\",\"Alt text\",\"输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. \",\"我们观察发现，输入链表l1和l2逆序存储数字，最后输出链表存储的数字也是逆序的，如果单看链表存储的话，发现进位也是逆序的，即进位不是向左进位，而是向右进位。可以维护一个int类型的变量index，用来处理进位。\",\"class ListNode{ ListNode next; int val; ListNode(){} ListNode(int val){ this.val = val; } ListNode(int val,ListNode next){ this.val = val; this.next = next; } } class Solution{ public ListNode addTwoNums(ListNode l1,ListNode l2){ // 使用虚拟头结点是为了方便处理第一个节点 ListNode dummy = new ListNode(); // 因为要有输出链表，所以定义一个cur，后面会将下一个节点拼到cur节点的后面 ListNode cur = dummy; int index = 0; // 如果index不为0，说明下一个节点需要处理进位 while(index != 0 || l1 != null || l2 != null){ // 终止条件是l1所在节点为null，即走完链表 if(l1 != null){ index += l1.val; } if(l2 != null){ index += l2.val; } cur = cur.next = new ListNode(index % 10); index /= 10; if(l1 != null){ l1 = l1.next; } if(l2 != null){ l2 = l2.next; } } return dummy.next; } } \"]},\"105\":{\"c\":[\"中等\"]},\"106\":{\"c\":[\"链表\",\"数学\"]},\"107\":{\"h\":\"11.环形链表\",\"t\":[\"给你一个链表的头节点 head ，判断链表中是否有环。\",\"如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\",\"如果链表中存在环 ，则返回 true 。 否则，返回 false 。\",\"输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 \"]},\"108\":{\"h\":\"思路\",\"t\":[\"可以用快慢指针，快指针每次走两步，慢指针每次走一步，如果有环，就一定相遇。那终止条件是什么呢？因为快指针每次要往后移动两步，所以fast.next肯定不为null，同理fast也不能为null。\",\"class ListNode{ int val; ListNode next; ListNode(){} ListNode(int x){ val = x; next = null; } } class Solution{ public boolean hasCycle(ListNode head){ if(head == null){ return false; } ListNode fast = head; ListNode slow = head; while(fast != null && fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ return true; } } return false; } } \"]},\"109\":{\"c\":[\"链表\"]},\"110\":{\"c\":[\"双指针\"]},\"111\":{\"h\":\"7.路径总和\",\"t\":[\"给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\",\"叶子节点 是指没有子节点的节点。\",\"输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 \"]},\"112\":{\"h\":\"思路\",\"t\":[\"要求根节点到叶子节点这条路径上的节点之和，等于目标和，所以需要判断当前的节点是否是根节点。每遍历一个节点，目标和就减去节点的值，遍历到根节点时，判断这个计数器是否为0。\",\"public class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(){} TreeNode(int val){ this.val = val; } TreeNode(int val,TreeNode left,TreeNode right){ this.val = val; this.left = left; this.right = right; } } public class Solution{ // 这个函数隐含着回溯的细节，因为是把targetSum作为参数整体传进去的 // 函数结束后，targetSum的值并没有改变 public boolean hasPathSum(TreeNode root,int targetSum){ if(root == null){ return false; } targetSum -= root.val; if(root.left == null && root.right == null){ return targetSum == 0; } if(root.left != null){ if(hasPathSum(root.left,targetSum)){ return true; } } if(root.right != null){ if(hasPathSum(root.right,targetSum)){ return true; } } return false; } } \"]},\"113\":{\"c\":[\"算法\",\"二叉树\"]},\"114\":{\"c\":[\"深度优先搜索\",\"回溯\"]},\"115\":{\"h\":\"10.单词搜索\",\"t\":[\"给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\",\"单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\",\"输入：board = [[\\\"A\\\",\\\"B\\\",\\\"C\\\",\\\"E\\\"],[\\\"S\\\",\\\"F\\\",\\\"C\\\",\\\"S\\\"],[\\\"A\\\",\\\"D\\\",\\\"E\\\",\\\"E\\\"]], word = \\\"ABCCED\\\" 输出：true \"]},\"116\":{\"h\":\"思路\",\"t\":[\"题目要求有两点需要注意的，一是字母不允许被重复使用，所以可以定义一个boolean类型的数组，来标记二维数组中的某个元素是否被访问过。二是最后返回是否找到这个单词，可以定义一个boolean类型的数值来标记是否找到。\",\"搜索方式可以使用深度优先搜索，一直搜，直到到头或者不满足条件再回溯，使用我们定义的boolean类型的数组来标记某个元素被访问过，回溯后，因为选择其他位置再次寻找，要再标记成未访问。\",\"class Solution{ boolean find = false; public boolean exist(char[][] board,String word){ if(board == null || word == null){ return false; } int m = board.length; int n = board[0].length; boolean visited[][] = new boolean[m][n]; for(int i = 0;i < m;i++){ for(int j = 0;j < n;j++){ dfs(i,j,board,visited,word,0); } } return find; } void dfs(int i,int j,char[][] board,boolean[][]visited,String word,int pos){ if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || find || visited[i][j] || board[i][j] != word.charAt(pos)){ return; } if(pos == word.length()-1){ find = true; return; } visited[i][j] = true; dfs(i+1,j,board,visited,word,pos+1); dfs(i-1,j,board,visited,word,pos+1); dfs(i,j+1,board,visited,word,pos+1); dfs(i,j-1,board,visited,word,pos+1); visited[i][j] = false; } } \"]},\"117\":{\"c\":[\"深度优先搜索\",\"二维矩阵\"]},\"118\":{\"c\":[\"中等\"]},\"119\":{\"h\":\"5.字符串相加\",\"t\":[\"给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。\",\"你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。\",\"输入：num1 = \\\"11\\\", num2 = \\\"123\\\" 输出：\\\"134\\\" \"]},\"120\":{\"h\":\"思路\",\"t\":[\"如果字符串不能转成整型再相加，我们可以模拟一下两数相加的过程。要注意如何进位，进位后当前结果是什么，下一个结果怎么计算，如何处理溢出情况。\",\"public String calculateString(String num1,String num2){ StringBuilder res = new StringBuilder(\\\"\\\"); int i = num1.length()-1; int j = num2.length()-1; int carry = 0; while(i >= 0 || j >= 0){ // 将字符串暂时处理成整数的操作 int m = i >= 0 ? num1.charAt(i)-'0' : 0; int n = j >= 0 ? num2.charAt(j)-'0' : 0; int temp = m + n + carry; carry = temp / 10; res.append(temp%10); // 不要忘记移动指针 i--; j--; } if(carry == 1){ res.append(carry); } return res.reverse().toString(); } \"]},\"121\":{\"c\":[\"模拟\"]},\"122\":{\"c\":[\"双指针\"]},\"123\":{\"h\":\"Posts\"},\"124\":{\"h\":\"Java\"},\"125\":{\"h\":\"Leetcode\"}},\"dirtCount\":0,\"index\":[[\"模拟\",{\"2\":{\"121\":1}}],[\"模仿别人\",{\"1\":{\"0\":1}}],[\"进位后当前结果是什么\",{\"1\":{\"120\":1}}],[\"进去的操作\",{\"1\":{\"49\":1}}],[\"搜索方式可以使用深度优先搜索\",{\"1\":{\"116\":1}}],[\"单元格是那些水平相邻或垂直相邻的单元格\",{\"1\":{\"115\":1}}],[\"单词必须按照字母顺序\",{\"1\":{\"115\":1}}],[\"单词搜索\",{\"0\":{\"115\":1}}],[\"相邻\",{\"1\":{\"115\":1}}],[\"存在于网格中\",{\"1\":{\"115\":1}}],[\"存储的键值对数量和哈希表大小的比例\",{\"1\":{\"65\":1}}],[\"深度优先搜索\",{\"2\":{\"114\":1,\"117\":1}}],[\"函数结束后\",{\"1\":{\"112\":1}}],[\"目标和就减去节点的值\",{\"1\":{\"112\":1}}],[\"目标对象和代理对象都要进行修改\",{\"1\":{\"54\":1}}],[\"每遍历一个节点\",{\"1\":{\"112\":1}}],[\"每个接口都进行判断\",{\"1\":{\"48\":1}}],[\"等于目标和\",{\"1\":{\"112\":1}}],[\"等于目标和的根节点到叶节点路径如上图所示\",{\"1\":{\"111\":1}}],[\"叶子节点\",{\"1\":{\"111\":1}}],[\"根节点到叶子节点\",{\"1\":{\"111\":1}}],[\"路径总和\",{\"0\":{\"111\":1}}],[\"x\",{\"1\":{\"108\":2,\"115\":1}}],[\"慢指针每次走一步\",{\"1\":{\"108\":1}}],[\"快指针每次走两步\",{\"1\":{\"108\":1}}],[\"其中\",{\"1\":{\"115\":1}}],[\"其尾部连接到第二个节点\",{\"1\":{\"107\":1}}],[\"其实就是维护一个最大值\",{\"1\":{\"83\":1}}],[\"其实选择什么语言没那么重要\",{\"1\":{\"2\":1}}],[\"否则\",{\"1\":{\"107\":1,\"111\":1,\"115\":1}}],[\"仅仅是为了标识链表的实际情况\",{\"1\":{\"107\":1}}],[\"注意\",{\"1\":{\"107\":1}}],[\"注意边界条件\",{\"1\":{\"93\":1}}],[\"开始\",{\"1\":{\"107\":1}}],[\"开头\",{\"1\":{\"104\":1}}],[\"索引从\",{\"1\":{\"107\":1}}],[\"来标记二维数组中的某个元素是否被访问过\",{\"1\":{\"116\":1}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"107\":1}}],[\"来保证服务器的身份是可信的\",{\"1\":{\"41\":1}}],[\"评测系统内部使用整数\",{\"1\":{\"107\":1}}],[\"环形链表\",{\"0\":{\"107\":1}}],[\"终止条件是l1所在节点为null\",{\"1\":{\"104\":1}}],[\"说明下一个节点需要处理进位\",{\"1\":{\"104\":1}}],[\"说明出现过\",{\"1\":{\"73\":1}}],[\"7\",{\"0\":{\"111\":1},\"1\":{\"104\":1,\"111\":1}}],[\"75\",{\"1\":{\"65\":1}}],[\"之外\",{\"1\":{\"104\":1}}],[\"之前可能多个元素会通过拉链法放在同一个索引上\",{\"1\":{\"67\":1}}],[\"并以相同形式返回一个表示和的链表\",{\"1\":{\"104\":1}}],[\"并且统计岛屿数量呢\",{\"1\":{\"93\":1}}],[\"并且每个节点只能存储\",{\"1\":{\"104\":1}}],[\"并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成\",{\"1\":{\"92\":1}}],[\"并且每遍历一个节点\",{\"1\":{\"78\":1}}],[\"并且start记录每个不重复字符串的初始位置\",{\"1\":{\"73\":1}}],[\"并且重新计算hash值\",{\"1\":{\"68\":1}}],[\"并且可以被重新赋值和修改\",{\"1\":{\"57\":1}}],[\"并且要有初始值\",{\"1\":{\"57\":1}}],[\"并且封装成一个类用来判断权限\",{\"1\":{\"49\":1}}],[\"并且https需要向ca\",{\"1\":{\"41\":1}}],[\"并且get请求的参数只允许有ascii码\",{\"1\":{\"40\":1}}],[\"并且如果是不需要长时间通信的功能或者接口\",{\"1\":{\"28\":1}}],[\"并且也是基于tcp协议的\",{\"1\":{\"28\":1}}],[\"并且弹幕模块本来就是一个长时间请求弹幕的过程\",{\"1\":{\"28\":1}}],[\"并且是单向的\",{\"1\":{\"27\":1}}],[\"并且技术设计上配合前端采用分片上传\",{\"1\":{\"7\":1}}],[\"逆序\",{\"1\":{\"104\":1}}],[\"它们每位数字都是按照\",{\"1\":{\"104\":1}}],[\"非空\",{\"1\":{\"104\":1}}],[\"两数相加\",{\"0\":{\"104\":1}}],[\"两个数组的交集ii\",{\"0\":{\"100\":1}}],[\"两个字\",{\"1\":{\"41\":1}}],[\"6\",{\"0\":{\"104\":1},\"1\":{\"104\":1}}],[\"简单\",{\"2\":{\"103\":1}}],[\"简单来说\",{\"1\":{\"66\":1}}],[\"继续判断\",{\"1\":{\"101\":1}}],[\"继续向前走\",{\"1\":{\"0\":1}}],[\"指针再次到达\",{\"1\":{\"107\":1}}],[\"指针继续向后移动\",{\"1\":{\"101\":1}}],[\"指针要向前反转一次\",{\"1\":{\"78\":1}}],[\"寻找两个数组中相同的元素\",{\"1\":{\"101\":1}}],[\"应与元素在两个数组中都出现的次数一致\",{\"1\":{\"100\":1}}],[\"应用场景比如spring\",{\"1\":{\"61\":1}}],[\"应用注解\",{\"0\":{\"53\":1}}],[\"应用数据从应用层传到传输层\",{\"1\":{\"40\":1}}],[\"应用层只需要专注为用户提供服务\",{\"1\":{\"39\":1}}],[\"应用层是用户直接接触到的最上层\",{\"1\":{\"39\":1}}],[\"应用层\",{\"0\":{\"39\":1}}],[\"9\",{\"0\":{\"100\":1},\"1\":{\"100\":4}}],[\"迭代\",{\"2\":{\"99\":1}}],[\"收集结果的时候\",{\"1\":{\"97\":1}}],[\"适合用栈来模拟\",{\"1\":{\"97\":1}}],[\"适合用队列\",{\"1\":{\"97\":1}}],[\"先上层\",{\"1\":{\"97\":1}}],[\"先查布隆\",{\"1\":{\"22\":1}}],[\"刚好满足先进先出\",{\"1\":{\"97\":1}}],[\"遍历到根节点时\",{\"1\":{\"112\":1}}],[\"遍历\",{\"1\":{\"96\":1}}],[\"遍历每一个节点时候\",{\"1\":{\"83\":1}}],[\"前序\",{\"1\":{\"96\":1}}],[\"返回\",{\"1\":{\"107\":1,\"111\":2,\"115\":2}}],[\"返回结果中每个元素出现的次数\",{\"1\":{\"100\":1}}],[\"返回栈顶元素并出栈\",{\"1\":{\"97\":1}}],[\"返回它节点值的\",{\"1\":{\"96\":1}}],[\"返回该树的最大直径\",{\"1\":{\"82\":1}}],[\"跳出搜索条件\",{\"1\":{\"93\":1}}],[\"变成一个岛屿\",{\"1\":{\"93\":1}}],[\"变的只是指针和null值的位置\",{\"1\":{\"78\":1}}],[\"下一个结果怎么计算\",{\"1\":{\"120\":1}}],[\"下次搜如何避免重复统计呢\",{\"1\":{\"93\":1}}],[\"下游\",{\"1\":{\"7\":1}}],[\"向右搜索\",{\"1\":{\"93\":1}}],[\"看看为不为\",{\"1\":{\"93\":2}}],[\"看到最长子串\",{\"1\":{\"73\":1}}],[\"出现的位置后\",{\"1\":{\"93\":1}}],[\"出现的位置\",{\"1\":{\"93\":1}}],[\"此外\",{\"1\":{\"92\":1}}],[\"此时null<\",{\"1\":{\"78\":1}}],[\"此时pre值指向链表的最后一个节点\",{\"1\":{\"78\":1}}],[\"此时是a\",{\"1\":{\"16\":1}}],[\"岛屿总是被水包围\",{\"1\":{\"92\":1}}],[\"岛屿数量是多少呢\",{\"1\":{\"93\":1}}],[\"岛屿数量\",{\"0\":{\"91\":1}}],[\"组成的二维网格\",{\"1\":{\"92\":1}}],[\"水\",{\"1\":{\"92\":1}}],[\"和num2\",{\"1\":{\"119\":1}}],[\"和一个字符串单词\",{\"1\":{\"115\":1}}],[\"和一个表示目标和的整数\",{\"1\":{\"111\":1}}],[\"和\",{\"1\":{\"92\":1,\"100\":1}}],[\"陆地\",{\"1\":{\"92\":1}}],[\"||\",{\"1\":{\"88\":1,\"93\":4,\"104\":2,\"116\":7,\"120\":1}}],[\"小于0就左指针向右移动\",{\"1\":{\"88\":1}}],[\"小公司可以优先采用rabbitmq\",{\"1\":{\"8\":1}}],[\"大于0就右指针向左移动\",{\"1\":{\"88\":1}}],[\"大家都说你努力\",{\"1\":{\"3\":1}}],[\"大家都知道了我的梦想和决心\",{\"1\":{\"0\":1}}],[\"大家都知道我的梦想\",{\"1\":{\"0\":1}}],[\"首先\",{\"1\":{\"93\":1}}],[\"首先我们可以先把数字进行排序\",{\"1\":{\"88\":1}}],[\"首先会请求服务器存入数据库中\",{\"1\":{\"7\":1}}],[\"且\",{\"1\":{\"87\":1}}],[\"请你将两个数相加\",{\"1\":{\"104\":1}}],[\"请你以数组形式返回两数组的交集\",{\"1\":{\"100\":1}}],[\"请你计算网格中的岛屿数量\",{\"1\":{\"92\":1}}],[\"请你找出其中不含有重复字符的\",{\"1\":{\"72\":1}}],[\"请找出所有和为\",{\"1\":{\"87\":1}}],[\"判断这个计数器是否为0\",{\"1\":{\"112\":1}}],[\"判断该树中是否存在\",{\"1\":{\"111\":1}}],[\"判断链表中是否有环\",{\"1\":{\"107\":1}}],[\"判断\",{\"1\":{\"87\":1}}],[\"个整数的数组\",{\"1\":{\"87\":1}}],[\"807\",{\"1\":{\"104\":1}}],[\"8\",{\"0\":{\"87\":1},\"1\":{\"100\":1,\"104\":1,\"111\":1}}],[\"递归\",{\"2\":{\"85\":1,\"95\":1}}],[\"同一个单元格内的字母不允许被重复使用\",{\"1\":{\"115\":1}}],[\"同理fast也不能为null\",{\"1\":{\"108\":1}}],[\"同时返回当前节点的最大路径即可\",{\"1\":{\"83\":1}}],[\"同样也是\",{\"1\":{\"1\":1}}],[\"保存最大值时\",{\"1\":{\"83\":1}}],[\"保证同一时间只有一个用户线程更新缓存\",{\"1\":{\"20\":1}}],[\"上一个节点的左右路径大小怎么保存下来\",{\"1\":{\"83\":1}}],[\"左右路径的大小即上一个节点的左右路径大小加一\",{\"1\":{\"83\":1}}],[\"所有的节点的左子树和右子树之和中的最大值\",{\"1\":{\"83\":1}}],[\"所以可以定义一个boolean类型的数组\",{\"1\":{\"116\":1}}],[\"所以需要判断当前的节点是否是根节点\",{\"1\":{\"112\":1}}],[\"所以fast\",{\"1\":{\"108\":1}}],[\"所以定义一个cur\",{\"1\":{\"104\":1}}],[\"所以给切面中具体的类加上\",{\"1\":{\"49\":1}}],[\"所以用什么技术\",{\"1\":{\"28\":1}}],[\"所以\",{\"1\":{\"27\":1}}],[\"所以查询很快\",{\"1\":{\"18\":1}}],[\"所以我们可以递归遍历二叉树的每一个节点\",{\"1\":{\"83\":1}}],[\"所以我们可以用消息队列把消息模块解耦出来\",{\"1\":{\"7\":1}}],[\"所以我们需要把这些公共的代码抽出来\",{\"1\":{\"49\":1}}],[\"所以我们用redis进行缓存\",{\"1\":{\"18\":1}}],[\"所以显而易见\",{\"1\":{\"16\":1}}],[\"所以商业化\",{\"1\":{\"8\":1}}],[\"所以采用消息队列\",{\"1\":{\"7\":1}}],[\"所以为了更好地实现关注功能\",{\"1\":{\"7\":1}}],[\"找到最大直径\",{\"1\":{\"83\":1}}],[\"找到master的最新记录\",{\"1\":{\"16\":1}}],[\"取路径\",{\"1\":{\"82\":1}}],[\"解释\",{\"1\":{\"82\":1,\"104\":1,\"107\":1,\"111\":1}}],[\"给定两个字符串形式的非负整数\",{\"1\":{\"119\":1}}],[\"给定一个\",{\"1\":{\"115\":1}}],[\"给定一个包含\",{\"1\":{\"87\":1}}],[\"给定一个字符串\",{\"1\":{\"72\":1}}],[\"给你两个\",{\"1\":{\"104\":1}}],[\"给你两个整数数组\",{\"1\":{\"100\":1}}],[\"给你二叉树的根节点\",{\"1\":{\"96\":1,\"111\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"107\":1}}],[\"给你一个由\",{\"1\":{\"92\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"82\":1}}],[\"已做3遍\",{\"2\":{\"86\":1}}],[\"已做7遍\",{\"2\":{\"80\":1}}],[\"已做4遍\",{\"2\":{\"75\":1}}],[\"双指针\",{\"2\":{\"80\":1,\"89\":1,\"102\":1,\"110\":1,\"122\":1}}],[\"链表中有一个环\",{\"1\":{\"107\":1}}],[\"链表\",{\"2\":{\"79\":1,\"106\":1,\"109\":1}}],[\"word\",{\"1\":{\"115\":3,\"116\":10}}],[\"while\",{\"1\":{\"78\":1,\"88\":3,\"97\":1,\"104\":1,\"108\":1,\"120\":1}}],[\"web开发\",{\"2\":{\"55\":1}}],[\"websocket\",{\"2\":{\"30\":1}}],[\"websocket协议没有http协议的请求头header\",{\"1\":{\"28\":1}}],[\"websocket好在哪里\",{\"0\":{\"28\":1}}],[\"别忘了写构造方法\",{\"1\":{\"78\":1}}],[\"发现进位也是逆序的\",{\"1\":{\"104\":1}}],[\"发现为\",{\"1\":{\"93\":1}}],[\"发现指针已经没了\",{\"1\":{\"78\":1}}],[\"发疯般\",{\"1\":{\"0\":1}}],[\"节点具体的值和位置是不变的\",{\"1\":{\"78\":1}}],[\"更清楚的\",{\"1\":{\"78\":1}}],[\"反转后\",{\"1\":{\"78\":1}}],[\"反转后应该是5\",{\"1\":{\"78\":1}}],[\"反转前\",{\"1\":{\"78\":1}}],[\"反转链表\",{\"0\":{\"76\":1}}],[\"5\",{\"0\":{\"119\":1},\"1\":{\"77\":2,\"78\":2,\"82\":2,\"100\":1,\"104\":1,\"111\":1}}],[\"465\",{\"1\":{\"104\":1}}],[\"4<\",{\"1\":{\"78\":2}}],[\"4\",{\"0\":{\"91\":1},\"1\":{\"77\":2,\"82\":2,\"87\":1,\"100\":4,\"104\":2,\"107\":1,\"111\":2}}],[\"滑动窗口\",{\"2\":{\"75\":1}}],[\"算法\",{\"2\":{\"74\":1,\"79\":1,\"113\":1}}],[\"+=\",{\"1\":{\"104\":2}}],[\"+\",{\"1\":{\"73\":1,\"84\":3,\"87\":2,\"88\":5,\"104\":1,\"120\":2}}],[\"<=\",{\"1\":{\"100\":2}}],[\"<\",{\"1\":{\"73\":1,\"88\":5,\"93\":4,\"101\":4,\"116\":4}}],[\"记录每个字符出现的下标\",{\"1\":{\"73\":1}}],[\"记录当前字符出现的上一次下标\",{\"1\":{\"73\":1}}],[\"记住做自己\",{\"1\":{\"0\":1}}],[\"直到到头或者不满足条件再回溯\",{\"1\":{\"116\":1}}],[\"直到走到头再回来继续朝另一个方向搜\",{\"1\":{\"93\":1}}],[\"直到遇到原链表的null值\",{\"1\":{\"78\":1}}],[\"直到遇到再次重复的时候\",{\"1\":{\"73\":1}}],[\"直接返回空的集合\",{\"1\":{\"88\":1}}],[\"直接调用构造方法类即可\",{\"1\":{\"60\":1}}],[\"第一次碰到重复的字符a时\",{\"1\":{\"73\":1}}],[\"第一步就是先定义自己的注解\",{\"1\":{\"51\":1}}],[\"字符串相加\",{\"0\":{\"119\":1}}],[\"字符串一共有128个ascii码\",{\"1\":{\"73\":1}}],[\"字符串\",{\"1\":{\"73\":1},\"2\":{\"74\":1}}],[\"本题有两个关键点\",{\"1\":{\"73\":1}}],[\"342\",{\"1\":{\"104\":1}}],[\"3<\",{\"1\":{\"78\":2}}],[\"3\",{\"0\":{\"81\":1},\"1\":{\"72\":2,\"77\":2,\"82\":4,\"96\":2,\"104\":1,\"107\":1}}],[\"输出\",{\"1\":{\"72\":2,\"77\":1,\"82\":1,\"87\":2,\"92\":1,\"96\":1,\"100\":2,\"104\":1,\"107\":1,\"111\":1,\"115\":1,\"119\":1}}],[\"输入链表l1和l2逆序存储数字\",{\"1\":{\"104\":1}}],[\"输入\",{\"1\":{\"72\":2,\"77\":1,\"82\":1,\"87\":2,\"92\":1,\"96\":1,\"100\":2,\"104\":1,\"107\":1,\"111\":1,\"115\":1,\"119\":1}}],[\"题目要求有两点需要注意的\",{\"1\":{\"116\":1}}],[\"题目可以拆解成两个要求\",{\"1\":{\"88\":1}}],[\"题目\",{\"0\":{\"72\":1,\"77\":1,\"82\":1,\"92\":1}}],[\"减少hash碰撞\",{\"1\":{\"68\":1}}],[\"计算它们的和并同样以字符串形式返回\",{\"1\":{\"119\":1}}],[\"计算hash值是为了将元素分布得更均匀\",{\"1\":{\"68\":1}}],[\"计算机网络\",{\"1\":{\"3\":1},\"2\":{\"29\":1,\"45\":1}}],[\"将字符串暂时处理成整数的操作\",{\"1\":{\"120\":1}}],[\"将之前旧的小容量数组中的元素复制过去\",{\"1\":{\"68\":1}}],[\"将信息存入消息队列后就直接返回\",{\"1\":{\"7\":1}}],[\"方法会声明一个更大容量的数组\",{\"1\":{\"68\":1}}],[\"数学\",{\"2\":{\"106\":1}}],[\"数字\",{\"1\":{\"104\":1}}],[\"数组是无法自动进行扩容的\",{\"1\":{\"68\":1}}],[\"数据链路层\",{\"1\":{\"44\":1}}],[\"数据是以明文的形式传输\",{\"1\":{\"41\":1}}],[\"数据压根就不存在\",{\"1\":{\"22\":1}}],[\"数据库\",{\"2\":{\"36\":1}}],[\"数据库的事务应该具有隔离性\",{\"1\":{\"34\":1}}],[\"数据库应该保持一致性的状态\",{\"1\":{\"33\":1}}],[\"数据库宕机\",{\"1\":{\"32\":1}}],[\"数据库中没有web应用要请求的数据\",{\"1\":{\"22\":1}}],[\"数据库承受巨大压力\",{\"1\":{\"21\":1}}],[\"数据库压力过大\",{\"1\":{\"19\":1}}],[\"扩容机制\",{\"0\":{\"68\":1}}],[\"查找的时间复杂度就是o\",{\"1\":{\"67\":1}}],[\"查询的时候还需要遍历链表\",{\"1\":{\"67\":1}}],[\"查询效率也会更快\",{\"1\":{\"67\":1}}],[\"时间复杂度o\",{\"1\":{\"67\":1}}],[\"时不时地帮助我\",{\"1\":{\"0\":1}}],[\"达到一定容量后会扩容\",{\"1\":{\"67\":1}}],[\"容易出现哈希冲突\",{\"1\":{\"66\":1}}],[\"容易被被篡改\",{\"1\":{\"41\":1}}],[\"分别指向两个数组\",{\"1\":{\"101\":1}}],[\"分布是比较均匀的\",{\"1\":{\"66\":1}}],[\"分层模型\",{\"2\":{\"46\":1}}],[\"映射到实际的存储位置上\",{\"1\":{\"66\":1}}],[\"得到最终的hash值\",{\"1\":{\"66\":1}}],[\"插入的是链表尾部\",{\"1\":{\"66\":1}}],[\"则返回\",{\"1\":{\"107\":1}}],[\"则链表中存在环\",{\"1\":{\"107\":1}}],[\"则考虑取较小值\",{\"1\":{\"100\":1}}],[\"则直接插入\",{\"1\":{\"66\":1}}],[\"则映射到哈希表的第一个元素\",{\"1\":{\"65\":1}}],[\"背后调用了putval方法\",{\"1\":{\"66\":1}}],[\"负载因子是哈希表在扩容之前\",{\"1\":{\"65\":1}}],[\"默认为\",{\"1\":{\"73\":1}}],[\"默认是0\",{\"1\":{\"65\":1}}],[\"默认是16\",{\"1\":{\"65\":1}}],[\"默认端口也不一样\",{\"1\":{\"41\":1}}],[\"visited\",{\"1\":{\"116\":10}}],[\"val\",{\"1\":{\"78\":7,\"84\":7,\"97\":8,\"104\":9,\"108\":2,\"112\":8}}],[\"value\",{\"1\":{\"65\":1}}],[\"void\",{\"1\":{\"52\":2,\"93\":1,\"116\":1}}],[\"vo是对应前端的html\",{\"1\":{\"11\":1}}],[\"vo\",{\"0\":{\"11\":1}}],[\"key不能重复\",{\"1\":{\"65\":1}}],[\"key\",{\"1\":{\"65\":1}}],[\"kafka更适合大数据领域的实时计算和日志采集\",{\"1\":{\"8\":1}}],[\"kafka等\",{\"1\":{\"7\":1}}],[\"获取要调用的方法的method对象\",{\"1\":{\"62\":1}}],[\"object\",{\"1\":{\"62\":4}}],[\"order\",{\"1\":{\"52\":1}}],[\"底层原理都大量应用了反射机制\",{\"1\":{\"61\":1}}],[\"还可以调用这些属性和方法\",{\"1\":{\"61\":1}}],[\"还有一个点就是缓存无法命中的场景\",{\"1\":{\"20\":1}}],[\"概念\",{\"0\":{\"61\":1}}],[\"初始容量是哈希表的初始大小\",{\"1\":{\"65\":1}}],[\"初始化一个类之前我们已经知道这是一个什么类了\",{\"1\":{\"60\":1}}],[\"初中立志要上我们当地最好的高中\",{\"1\":{\"0\":1}}],[\"node\",{\"1\":{\"97\":6}}],[\"num2\",{\"1\":{\"119\":1,\"120\":3}}],[\"num1\",{\"1\":{\"119\":2,\"120\":3}}],[\"nums2\",{\"1\":{\"100\":4,\"101\":5}}],[\"nums1\",{\"1\":{\"100\":4,\"101\":6}}],[\"nums\",{\"1\":{\"87\":4,\"88\":22}}],[\"null\",{\"1\":{\"78\":4,\"84\":5,\"88\":1,\"96\":1,\"97\":3,\"104\":6,\"108\":4,\"111\":4,\"112\":5,\"116\":2}}],[\"null<\",{\"1\":{\"78\":2}}],[\"next肯定不为null\",{\"1\":{\"108\":1}}],[\"next\",{\"1\":{\"78\":7,\"104\":8,\"107\":1,\"108\":6}}],[\"newinstance\",{\"1\":{\"62\":1}}],[\"new\",{\"1\":{\"60\":1,\"73\":1,\"88\":1,\"97\":2,\"101\":2,\"104\":2,\"116\":1,\"120\":1}}],[\"n\",{\"1\":{\"67\":1,\"87\":1,\"115\":1,\"116\":3,\"120\":2}}],[\"nasa\",{\"1\":{\"4\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"107\":1}}],[\"为了符合前序遍历的顺序\",{\"1\":{\"97\":1}}],[\"为了便于区分\",{\"1\":{\"78\":1}}],[\"为一个类设置属性\",{\"1\":{\"60\":1}}],[\"为什么不用http协议\",{\"0\":{\"27\":1}}],[\"为什么不向其他领域探索呢\",{\"1\":{\"2\":1}}],[\"为什么用websocket协议而不是http\",{\"0\":{\"25\":1}}],[\"为什么我用了rocketmq呢\",{\"1\":{\"7\":1}}],[\"为什么选择rocketmq\",{\"0\":{\"8\":1}}],[\"为什么选择消息队列\",{\"0\":{\"7\":1}}],[\"为什么选择了软件开发\",{\"0\":{\"2\":1}}],[\"掌握java反射\",{\"0\":{\"60\":1}}],[\"强调所属关系\",{\"1\":{\"57\":1}}],[\"接口中的成员变量只能是public\",{\"1\":{\"57\":1}}],[\"接口主要是对类的行为进行约束\",{\"1\":{\"57\":1}}],[\"接口名\",{\"1\":{\"57\":1}}],[\"接口的声明是public\",{\"1\":{\"57\":1}}],[\"接口进行权限控制\",{\"1\":{\"48\":1}}],[\"类名\",{\"1\":{\"57\":1}}],[\"抽象类中的成员变量默认default\",{\"1\":{\"57\":1}}],[\"抽象类主要用于代码复用\",{\"1\":{\"57\":1}}],[\"抽象类的声明是abstract\",{\"1\":{\"57\":1}}],[\"抽象类和接口的区别是什么\",{\"0\":{\"57\":1}}],[\"动态代理只需要实现接口即可\",{\"1\":{\"54\":1}}],[\"动态代理比静态代理更加灵活\",{\"1\":{\"54\":1}}],[\"什么是静态代理\",{\"1\":{\"54\":1}}],[\"具体的业务逻辑\",{\"1\":{\"53\":1}}],[\"通过相邻的单元格内的字母构成\",{\"1\":{\"115\":1}}],[\"通过invoke方法执行\",{\"1\":{\"62\":1}}],[\"通过construct对象初始化反射类对象\",{\"1\":{\"62\":1}}],[\"通过class对象获取构造方法construct对象\",{\"1\":{\"62\":1}}],[\"通过类的包名获取反射类\",{\"1\":{\"62\":1}}],[\"通过反射\",{\"1\":{\"61\":1}}],[\"通用的判断权限的业务逻辑\",{\"1\":{\"52\":1}}],[\"通常会在浏览器的搜索框携带一些参数\",{\"1\":{\"40\":1}}],[\"再push左子树\",{\"1\":{\"97\":1}}],[\"再回到原位\",{\"1\":{\"93\":1}}],[\"再说这两种动态代理方法有什么区别\",{\"1\":{\"54\":1}}],[\"再比如aop机制也应用了代理模式\",{\"1\":{\"54\":1}}],[\"再进行具体的业务逻辑\",{\"1\":{\"52\":1}}],[\"再把暂存的feature提交接上去\",{\"1\":{\"16\":1}}],[\"haspathsum\",{\"1\":{\"112\":3}}],[\"hascycle\",{\"1\":{\"108\":1}}],[\"hashmap\",{\"2\":{\"70\":1}}],[\"hashmap的resize\",{\"1\":{\"68\":1}}],[\"hashmap的底层是用数组实现的\",{\"1\":{\"67\":1}}],[\"hashmap的底层存储\",{\"0\":{\"67\":1}}],[\"hashmap的键和值都可以为null\",{\"1\":{\"65\":1}}],[\"hashmap有一个初始容量和负载因子\",{\"1\":{\"65\":1}}],[\"hashmap实现了map接口\",{\"1\":{\"65\":1}}],[\"hashmap总结\",{\"0\":{\"65\":1}}],[\"head\",{\"1\":{\"77\":1,\"78\":3,\"107\":2,\"108\":4}}],[\"houbingzhi\",{\"1\":{\"52\":1,\"62\":1}}],[\"https默认端口是443\",{\"1\":{\"41\":1}}],[\"http是超文本传输协议\",{\"1\":{\"41\":1}}],[\"http还有一个post请求\",{\"1\":{\"40\":1}}],[\"http本身是不会对url的长度进行限制\",{\"1\":{\"40\":1}}],[\"http协议默认端口是80\",{\"1\":{\"41\":1}}],[\"http协议和https的区别是什么\",{\"0\":{\"41\":1}}],[\"http协议协议虽然多了个请求头header\",{\"1\":{\"28\":1}}],[\"http协议是短连接\",{\"1\":{\"27\":1}}],[\"程序就无法被aop代理\",{\"1\":{\"52\":1}}],[\"usermoment\",{\"1\":{\"53\":2}}],[\"user\",{\"1\":{\"53\":1,\"60\":4,\"62\":1}}],[\"userroleservice\",{\"1\":{\"52\":2}}],[\"usersupport\",{\"1\":{\"52\":2}}],[\"carry\",{\"1\":{\"120\":5}}],[\"calculatestring\",{\"1\":{\"120\":1}}],[\"c\",{\"1\":{\"87\":2,\"115\":2}}],[\"cur的next指针指向pre\",{\"1\":{\"78\":1}}],[\"cur\",{\"1\":{\"78\":6,\"104\":3}}],[\"cur指针往后走一步\",{\"1\":{\"78\":1}}],[\"cur指针的next指针指向pre后\",{\"1\":{\"78\":1}}],[\"cur指针指向head节点\",{\"1\":{\"78\":1}}],[\"char\",{\"1\":{\"93\":2,\"116\":2}}],[\"charat\",{\"1\":{\"73\":1,\"116\":1,\"120\":2}}],[\"check\",{\"1\":{\"52\":2}}],[\"continue\",{\"1\":{\"88\":1}}],[\"constructor\",{\"1\":{\"62\":3}}],[\"com\",{\"1\":{\"52\":1,\"62\":1}}],[\"component让spring进行管理\",{\"1\":{\"54\":1}}],[\"component\",{\"1\":{\"51\":2,\"52\":1}}],[\"clazz\",{\"1\":{\"62\":4}}],[\"class\",{\"1\":{\"52\":1,\"57\":1,\"62\":4,\"78\":2,\"84\":2,\"88\":1,\"97\":2,\"101\":1,\"104\":2,\"108\":2,\"112\":2,\"116\":1}}],[\"定义切面\",{\"0\":{\"52\":1}}],[\"l2\",{\"1\":{\"104\":8}}],[\"l1\",{\"1\":{\"104\":8}}],[\"l+1\",{\"1\":{\"88\":1}}],[\"l++\",{\"1\":{\"88\":3}}],[\"l\",{\"1\":{\"88\":8}}],[\"leetcode\",{\"0\":{\"125\":1}}],[\"leftsize\",{\"1\":{\"84\":3}}],[\"left\",{\"1\":{\"84\":7,\"97\":6,\"112\":7}}],[\"length\",{\"1\":{\"73\":1,\"88\":3,\"93\":4,\"100\":2,\"101\":2,\"116\":5,\"120\":2}}],[\"list\",{\"1\":{\"101\":5}}],[\"list<integer>\",{\"1\":{\"97\":2,\"101\":1}}],[\"list<list<integer>>\",{\"1\":{\"88\":2}}],[\"listnode\",{\"1\":{\"78\":11,\"104\":13,\"108\":7}}],[\"limitedrolecodelist\",{\"1\":{\"51\":1,\"53\":1}}],[\"last\",{\"1\":{\"73\":4}}],[\"lv0\",{\"1\":{\"53\":1}}],[\"long\",{\"1\":{\"13\":4}}],[\"isempty\",{\"1\":{\"97\":1}}],[\"i+1\",{\"1\":{\"93\":1,\"116\":1}}],[\"i++\",{\"1\":{\"73\":1,\"88\":1,\"93\":1,\"101\":3,\"116\":1}}],[\"if\",{\"1\":{\"78\":1,\"84\":2,\"88\":5,\"93\":2,\"97\":3,\"101\":2,\"104\":4,\"108\":2,\"112\":6,\"116\":3,\"120\":1}}],[\"i\",{\"1\":{\"73\":5,\"88\":10,\"93\":12,\"101\":9,\"116\":13,\"120\":5}}],[\"index\",{\"1\":{\"73\":3,\"104\":6}}],[\"intersect\",{\"1\":{\"101\":1}}],[\"interface\",{\"1\":{\"51\":1,\"57\":1}}],[\"int\",{\"1\":{\"73\":7,\"78\":3,\"84\":8,\"88\":4,\"93\":6,\"97\":3,\"101\":7,\"104\":4,\"108\":2,\"112\":4,\"116\":7,\"120\":6}}],[\"invoke\",{\"1\":{\"62\":2}}],[\"ip四层模型是计算机网络实际应用的模型\",{\"1\":{\"38\":1}}],[\"ip四层模型\",{\"0\":{\"38\":1}}],[\"exist\",{\"1\":{\"116\":1}}],[\"exception\",{\"1\":{\"53\":1}}],[\"e\",{\"1\":{\"115\":3}}],[\"else\",{\"1\":{\"88\":2,\"101\":2}}],[\"elementtype\",{\"1\":{\"51\":1}}],[\"entity是实体类\",{\"1\":{\"11\":1}}],[\"entity的区别\",{\"0\":{\"11\":1}}],[\"后面会将下一个节点拼到cur节点的后面\",{\"1\":{\"104\":1}}],[\"后面进行依赖注入\",{\"1\":{\"51\":1}}],[\"后下层的顺序\",{\"1\":{\"97\":1}}],[\"后续对bean中方法的调用\",{\"1\":{\"54\":1}}],[\"后端承受的压力更大\",{\"1\":{\"7\":1}}],[\"切面才能工作\",{\"1\":{\"51\":1}}],[\"切问而近思\",{\"1\":{\"0\":1}}],[\"确定这个注解的位置后\",{\"1\":{\"51\":1}}],[\"声明注解\",{\"0\":{\"51\":1}}],[\"需要在切面里写\",{\"1\":{\"50\":1}}],[\"需求开发分支\",{\"1\":{\"16\":1}}],[\"代表中间什么东西也没有\",{\"1\":{\"78\":1}}],[\"代表生命周期\",{\"1\":{\"51\":1}}],[\"代表在目标方法调用之前执行\",{\"1\":{\"49\":1}}],[\"代码\",{\"0\":{\"84\":1}}],[\"代码实现\",{\"0\":{\"50\":1}}],[\"代码都要改不少处\",{\"1\":{\"7\":1}}],[\"代码背后为什么用这个数据类型而不是其他呢\",{\"1\":{\"3\":1}}],[\"叫切面\",{\"1\":{\"49\":1}}],[\"权限判断\",{\"1\":{\"49\":1}}],[\"slow\",{\"1\":{\"108\":4}}],[\"size\",{\"1\":{\"101\":2}}],[\"sort\",{\"1\":{\"88\":1,\"101\":2}}],[\"solution\",{\"1\":{\"78\":1,\"84\":1,\"88\":1,\"97\":1,\"101\":1,\"104\":1,\"108\":1,\"112\":1,\"116\":1}}],[\"s\",{\"1\":{\"72\":1,\"73\":3,\"115\":2}}],[\"s39\",{\"1\":{\"62\":1}}],[\"setnamemethod\",{\"1\":{\"62\":2}}],[\"setname\",{\"1\":{\"60\":1,\"62\":1}}],[\"stack<>\",{\"1\":{\"97\":1}}],[\"stack<treenode>\",{\"1\":{\"97\":1}}],[\"stack\",{\"1\":{\"97\":6}}],[\"start+1\",{\"1\":{\"73\":1}}],[\"start\",{\"1\":{\"73\":3}}],[\"start更新为这个下标的下一个\",{\"1\":{\"73\":1}}],[\"static\",{\"1\":{\"57\":1}}],[\"stringbuilder\",{\"1\":{\"120\":2}}],[\"string\",{\"1\":{\"51\":1,\"62\":1,\"73\":1,\"116\":2,\"120\":3}}],[\"success\",{\"1\":{\"53\":1}}],[\"spring这个优秀的框架中\",{\"1\":{\"54\":1}}],[\"spring\",{\"0\":{\"54\":1},\"1\":{\"49\":1,\"61\":1},\"2\":{\"56\":1}}],[\"smtp简单邮件传输协议\",{\"1\":{\"39\":1}}],[\"织入\",{\"1\":{\"49\":1}}],[\"只不过是岛屿的大小而已\",{\"1\":{\"93\":1}}],[\"只需要关注具体不同的逻辑即可\",{\"1\":{\"49\":1}}],[\"只用mysql进行查询是比较耗时的\",{\"1\":{\"18\":1}}],[\"思路\",{\"0\":{\"49\":1,\"73\":1,\"78\":1,\"83\":1,\"88\":1,\"93\":1,\"97\":1,\"101\":1,\"108\":1,\"112\":1,\"116\":1,\"120\":1}}],[\"无重复字符的最长字串\",{\"0\":{\"71\":1}}],[\"无法访问\",{\"1\":{\"48\":1}}],[\"无非是一遍两遍三遍四遍不停地去看\",{\"1\":{\"2\":1}}],[\"该层的传输协议有点对点协议ppp\",{\"1\":{\"44\":1}}],[\"该层有两个传输协议\",{\"1\":{\"42\":1}}],[\"封装成数据帧发送到网络上\",{\"1\":{\"44\":1}}],[\"实现主机与主机之间通信\",{\"1\":{\"43\":1}}],[\"实际上是代理类重写的代理方法\",{\"1\":{\"54\":1}}],[\"实际上是美国对华为的制裁和警告\",{\"1\":{\"1\":1}}],[\"实际上创建的是这个bean的代理对象\",{\"1\":{\"54\":1}}],[\"实际上可能不存在\",{\"1\":{\"22\":1}}],[\"帮助实现通信\",{\"1\":{\"43\":1}}],[\"作为数据传输的媒介\",{\"1\":{\"43\":1}}],[\"作为一个天资愚笨的学生\",{\"1\":{\"0\":1}}],[\"作为一个瘦弱的女生\",{\"1\":{\"0\":1}}],[\"传输数据从应用层传到传输层之后\",{\"1\":{\"42\":1}}],[\"传输控制协议tcp\",{\"1\":{\"42\":1}}],[\"传输层只负责服务好应用\",{\"1\":{\"43\":1}}],[\"传输层为上层\",{\"1\":{\"42\":1}}],[\"传输层\",{\"0\":{\"42\":1},\"1\":{\"38\":1}}],[\"申请数字证书\",{\"1\":{\"41\":1}}],[\"证书权威机构\",{\"1\":{\"41\":1}}],[\"才可进入加密报文传输\",{\"1\":{\"41\":1}}],[\"使得\",{\"1\":{\"87\":1}}],[\"使得报文能够加密传输\",{\"1\":{\"41\":1}}],[\"使用我们定义的boolean类型的数组来标记某个元素被访问过\",{\"1\":{\"116\":1}}],[\"使用虚拟头结点是为了方便处理第一个节点\",{\"1\":{\"104\":1}}],[\"使用git\",{\"1\":{\"16\":1}}],[\"使用redis来断点续传和秒传\",{\"1\":{\"7\":1}}],[\"安全\",{\"1\":{\"41\":1}}],[\"格式也只需要前后端协商好即可\",{\"1\":{\"40\":1}}],[\"浏览器对body的大小没有限制\",{\"1\":{\"40\":1}}],[\"preordertraversal\",{\"1\":{\"97\":1}}],[\"pre移动到cur的位置\",{\"1\":{\"78\":1}}],[\"pre\",{\"1\":{\"78\":4}}],[\"pre向后遍历\",{\"1\":{\"78\":1}}],[\"pre指针指向null值\",{\"1\":{\"78\":1}}],[\"pre即可\",{\"1\":{\"78\":1}}],[\"private\",{\"1\":{\"52\":2,\"84\":1,\"93\":1}}],[\"pos+1\",{\"1\":{\"116\":4}}],[\"pos\",{\"1\":{\"107\":3,\"116\":3}}],[\"posts\",{\"0\":{\"123\":1}}],[\"postmapping\",{\"1\":{\"53\":1}}],[\"post请求代表添加某个资源\",{\"1\":{\"40\":1}}],[\"pop\",{\"1\":{\"97\":1}}],[\"pointcut\",{\"1\":{\"52\":2}}],[\"push\",{\"1\":{\"97\":3}}],[\"put方法内部的执行流程\",{\"0\":{\"66\":1}}],[\"public\",{\"1\":{\"51\":1,\"52\":3,\"53\":1,\"73\":1,\"78\":1,\"84\":1,\"88\":1,\"93\":1,\"97\":1,\"101\":1,\"104\":1,\"108\":1,\"112\":3,\"116\":1,\"120\":1}}],[\"pull\",{\"1\":{\"16\":2}}],[\"经浏览器解析后\",{\"1\":{\"40\":1}}],[\"图片\",{\"1\":{\"40\":1}}],[\"视频\",{\"1\":{\"40\":1}}],[\"标签里包含了一些超链接\",{\"1\":{\"40\":1}}],[\"tostring\",{\"1\":{\"120\":1}}],[\"true\",{\"1\":{\"107\":2,\"108\":1,\"111\":2,\"112\":2,\"115\":2,\"116\":2}}],[\"treenode\",{\"1\":{\"84\":10,\"97\":10,\"112\":9}}],[\"text\",{\"1\":{\"104\":1}}],[\"temp\",{\"1\":{\"78\":2,\"120\":3}}],[\"telnet远程登陆协议等\",{\"1\":{\"39\":1}}],[\"threesum\",{\"1\":{\"88\":1}}],[\"throws\",{\"1\":{\"53\":1}}],[\"this\",{\"1\":{\"78\":3,\"84\":4,\"97\":4,\"104\":3,\"112\":4}}],[\"targetsum的值并没有改变\",{\"1\":{\"112\":1}}],[\"targetsum\",{\"1\":{\"111\":3,\"112\":5}}],[\"target\",{\"1\":{\"51\":2}}],[\"tls的握手过程\",{\"1\":{\"41\":1}}],[\"tls安全协议\",{\"1\":{\"41\":1}}],[\"tls安全协议用来加密\",{\"1\":{\"41\":1}}],[\"tcp\",{\"0\":{\"38\":1},\"1\":{\"38\":1}}],[\"tcp四次挥手释放连接\",{\"1\":{\"27\":2}}],[\"tcp三次握手建立连接\",{\"1\":{\"27\":2}}],[\"网络之间实际的传输功能是由网络层实现的\",{\"1\":{\"43\":1}}],[\"网络接口层\",{\"0\":{\"44\":1},\"1\":{\"38\":1}}],[\"网络层提供了ip协议\",{\"1\":{\"43\":1}}],[\"网络层\",{\"0\":{\"43\":1},\"1\":{\"38\":1}}],[\"网络编程\",{\"1\":{\"3\":1}}],[\"从而实现快速访问\",{\"1\":{\"65\":1}}],[\"从上到下分别是应用层\",{\"1\":{\"38\":1}}],[\"从高中二年级一直到报考专业\",{\"1\":{\"1\":1}}],[\"重要\",{\"2\":{\"37\":1,\"59\":1,\"64\":1}}],[\"持久性\",{\"0\":{\"35\":1}}],[\"持久性是手段\",{\"1\":{\"31\":1}}],[\"即走完链表\",{\"1\":{\"104\":1}}],[\"即进位不是向左进位\",{\"1\":{\"104\":1}}],[\"即temp=cur\",{\"1\":{\"78\":1}}],[\"即不同事务在不同的空间能够并发执行\",{\"1\":{\"34\":1}}],[\"即使check为空\",{\"1\":{\"52\":1}}],[\"即使数据库发生宕机\",{\"1\":{\"35\":1}}],[\"即使double类型的值是1\",{\"1\":{\"13\":1}}],[\"即使对芯片很热爱\",{\"1\":{\"1\":1}}],[\"加起来还是400元\",{\"1\":{\"33\":1}}],[\"加拿大非法拘禁华为创始人任正非的女儿\",{\"1\":{\"1\":1}}],[\"转账之后\",{\"1\":{\"33\":1}}],[\"明明a账户扣除了100元\",{\"1\":{\"32\":1}}],[\"回溯后\",{\"1\":{\"116\":1}}],[\"回溯\",{\"2\":{\"114\":1}}],[\"回到操作1之前的状态\",{\"1\":{\"32\":1}}],[\"回头看看路\",{\"1\":{\"0\":1}}],[\"整个事务应该回滚\",{\"1\":{\"32\":1}}],[\"操作2没有发生\",{\"1\":{\"32\":1}}],[\"操作2应该是b的账户增加100元\",{\"1\":{\"32\":1}}],[\"操作1是a的账户扣除100元\",{\"1\":{\"32\":1}}],[\"隔离性\",{\"0\":{\"34\":1},\"1\":{\"31\":1}}],[\"事务有四大特性\",{\"1\":{\"31\":1}}],[\"事务的acid\",{\"0\":{\"31\":1}}],[\"事实是\",{\"1\":{\"2\":1}}],[\"原子性\",{\"0\":{\"32\":1},\"1\":{\"31\":1}}],[\"原创\",{\"2\":{\"30\":1}}],[\"原理学好了\",{\"1\":{\"2\":1}}],[\"架构如何设计\",{\"1\":{\"28\":1}}],[\"消息速度更快\",{\"1\":{\"28\":1}}],[\"消息队列主要用于消息的传输和通信\",{\"1\":{\"7\":1}}],[\"消息队列尽可能来处理\",{\"1\":{\"7\":1}}],[\"消息队列的解耦\",{\"1\":{\"7\":1}}],[\"消息队列的异步和削峰\",{\"1\":{\"7\":1}}],[\"消息队列的发布\",{\"1\":{\"7\":1}}],[\"除了get请求\",{\"1\":{\"40\":1}}],[\"除了基础的增删改查\",{\"1\":{\"3\":1}}],[\"除此之外\",{\"1\":{\"28\":1,\"41\":1}}],[\"断开连接消耗资源\",{\"1\":{\"28\":1}}],[\"服务端也能向客户端推送资源\",{\"1\":{\"28\":1}}],[\"客户端还是要不断轮询\",{\"1\":{\"27\":1}}],[\"客户端需要不停地轮询服务端\",{\"1\":{\"27\":1}}],[\"拉取资源\",{\"1\":{\"27\":2}}],[\"建立连接和释放连接的过程也是要消耗资源的\",{\"1\":{\"27\":1}}],[\"你不能使用任何內建的用于处理大整数的库\",{\"1\":{\"119\":1}}],[\"你可以假设除了数字\",{\"1\":{\"104\":1}}],[\"你可以假设该网格的四条边均被水包围\",{\"1\":{\"92\":1}}],[\"你那有没有资源\",{\"1\":{\"27\":1}}],[\"你好\",{\"1\":{\"3\":1}}],[\"效果如何\",{\"1\":{\"27\":1}}],[\"然后定义两个指针\",{\"1\":{\"101\":1}}],[\"然后将hash值去模\",{\"1\":{\"66\":1}}],[\"然后用hash方法将其低位和高位进行异或操作\",{\"1\":{\"66\":1}}],[\"然后我们为这个对象配置了一个切面\",{\"1\":{\"54\":1}}],[\"然后看到了视频上方的弹幕\",{\"1\":{\"26\":1}}],[\"然后删掉feature的提交记录\",{\"1\":{\"16\":1}}],[\"用迭代法怎么实现\",{\"1\":{\"97\":1}}],[\"用递归法很简单\",{\"1\":{\"97\":1}}],[\"用双指针寻找另外两个数字\",{\"1\":{\"88\":1}}],[\"用来处理进位\",{\"1\":{\"104\":1}}],[\"用来反转后代表null值\",{\"1\":{\"78\":1}}],[\"用来将网络层传输的数据包封装成帧\",{\"1\":{\"44\":1}}],[\"用户数据报协议udp\",{\"1\":{\"42\":1}}],[\"用户进入我们的系统\",{\"1\":{\"26\":1}}],[\"用websocket的长连接反而会长时间占用内存这些资源\",{\"1\":{\"28\":1}}],[\"用http的短连接更好\",{\"1\":{\"28\":1}}],[\"用长连接更适合\",{\"1\":{\"28\":1}}],[\"用rocketmq是完全可以的\",{\"1\":{\"8\":1}}],[\"场景是这样的\",{\"1\":{\"26\":1}}],[\"功能\",{\"1\":{\"26\":1}}],[\"推送弹幕\",{\"1\":{\"26\":1}}],[\"推送给所有用户\",{\"1\":{\"7\":1}}],[\"推送给所有正在观看的用户\",{\"1\":{\"7\":1}}],[\"现在需要实现一个用户发送弹幕和获取弹幕\",{\"1\":{\"26\":1}}],[\"业务背景是一个类似于b站的视频弹幕系统\",{\"1\":{\"26\":1}}],[\"业务需求\",{\"0\":{\"26\":1,\"48\":1}}],[\"业务理解能力\",{\"1\":{\"3\":1}}],[\"面试高频\",{\"2\":{\"24\":1}}],[\"布隆过滤器\",{\"1\":{\"22\":1}}],[\"未能获取互斥锁的请求\",{\"1\":{\"20\":1}}],[\"未来可能还会开发视频推送功能\",{\"1\":{\"7\":1}}],[\"未来的职业规划\",{\"0\":{\"3\":1}}],[\"未来的工程师开始启航\",{\"0\":{\"1\":1}}],[\"提供了数据链路级别的功能\",{\"1\":{\"44\":1}}],[\"提供网络支持\",{\"1\":{\"42\":1}}],[\"提交后文本会写到报文body中\",{\"1\":{\"40\":1}}],[\"提前通知后台线程更新缓存以及重新设置更新时间\",{\"1\":{\"20\":1}}],[\"提醒自己\",{\"1\":{\"0\":1}}],[\"由后台异步更新缓存\",{\"1\":{\"20\":1}}],[\"如何处理溢出情况\",{\"1\":{\"120\":1}}],[\"如何再向下一个遍历\",{\"1\":{\"78\":1}}],[\"如何保证安全的呢\",{\"1\":{\"41\":1}}],[\"如何解决\",{\"0\":{\"20\":1,\"22\":1}}],[\"如果字符串不能转成整型再相加\",{\"1\":{\"120\":1}}],[\"如果\",{\"1\":{\"115\":1}}],[\"如果存在\",{\"1\":{\"111\":1}}],[\"如果存在再向缓存中查询数据\",{\"1\":{\"22\":1}}],[\"如果链表中存在环\",{\"1\":{\"107\":1}}],[\"如果链表中有某个节点\",{\"1\":{\"107\":1}}],[\"如果index不为0\",{\"1\":{\"104\":1}}],[\"如果单看链表存储的话\",{\"1\":{\"104\":1}}],[\"如果相同就把对应的元素收集起来\",{\"1\":{\"101\":1}}],[\"如果相同就直接覆盖\",{\"1\":{\"66\":1}}],[\"如果出现次数不一致\",{\"1\":{\"100\":1}}],[\"如果三元组的第一个数字就是大于0的\",{\"1\":{\"88\":1}}],[\"如果当前节点的左右子树不为空\",{\"1\":{\"83\":1}}],[\"如果下次访问发现不为\",{\"1\":{\"73\":1}}],[\"如果位置多了\",{\"1\":{\"67\":1}}],[\"如果简单进行相加或与操作\",{\"1\":{\"66\":1}}],[\"如果不大于0\",{\"1\":{\"88\":1}}],[\"如果不是就遍历链表插入\",{\"1\":{\"66\":1}}],[\"如果不同就调整指针位置\",{\"1\":{\"101\":1}}],[\"如果不同\",{\"1\":{\"66\":1}}],[\"如果不存在就直接返回\",{\"1\":{\"22\":1}}],[\"如果没有出现过\",{\"1\":{\"73\":1}}],[\"如果没有元素\",{\"1\":{\"66\":1}}],[\"如果没有实现接口\",{\"1\":{\"54\":1}}],[\"如果键为null\",{\"1\":{\"65\":1}}],[\"如果被代理的类有实现的接口\",{\"1\":{\"54\":1}}],[\"如果接口中的方法变了\",{\"1\":{\"54\":1}}],[\"如果权限不足\",{\"1\":{\"48\":1}}],[\"如果服务器此时就没有新增的资源\",{\"1\":{\"27\":1}}],[\"如果有环\",{\"1\":{\"108\":1}}],[\"如果有元素\",{\"1\":{\"66\":1}}],[\"如果有\",{\"1\":{\"27\":1}}],[\"如果布隆判断不存在\",{\"1\":{\"22\":1}}],[\"如果此时有两个分支\",{\"1\":{\"16\":1}}],[\"如果用entity会造成资源的消耗\",{\"1\":{\"11\":1}}],[\"如果数据量不大\",{\"1\":{\"8\":1}}],[\"如果我们不知道这是一个什么样的类\",{\"1\":{\"60\":1}}],[\"如果我们采用传统的http协议\",{\"1\":{\"27\":1}}],[\"如果我们在feature分支开发一段时间后\",{\"1\":{\"16\":1}}],[\"如果我们把这些功能都写到一个模块中\",{\"1\":{\"7\":1}}],[\"如果我能在其他领域做出对这个世界有积极意义的产品\",{\"1\":{\"2\":1}}],[\"如果是前中后序遍历\",{\"1\":{\"97\":1}}],[\"如果是层序遍历\",{\"1\":{\"97\":1}}],[\"如果是就调用puttreeval将元素添加进去\",{\"1\":{\"66\":1}}],[\"如果是大用户量\",{\"1\":{\"7\":1}}],[\"如果是传统的队列模式\",{\"1\":{\"7\":1}}],[\"如果时间可以倒流\",{\"1\":{\"3\":1}}],[\"到redis读取数据\",{\"1\":{\"19\":1,\"21\":1}}],[\"滴滴面试题\",{\"1\":{\"18\":1}}],[\"今天来重点讲一下缓存击穿和缓存穿透\",{\"1\":{\"18\":1}}],[\"缓存\",{\"2\":{\"24\":1}}],[\"缓存空值或默认值\",{\"1\":{\"22\":1}}],[\"缓存无法命中\",{\"1\":{\"19\":1,\"21\":1}}],[\"缓存穿透\",{\"0\":{\"21\":1},\"1\":{\"18\":1}}],[\"缓存击穿的原因就是热点数据缓存过期\",{\"1\":{\"20\":1}}],[\"缓存击穿\",{\"0\":{\"19\":1},\"1\":{\"18\":1}}],[\"缓存击穿和缓存穿透如何解决\",{\"0\":{\"18\":1}}],[\"或者\",{\"1\":{\"82\":1}}],[\"或者当热点数据快要过期的时候\",{\"1\":{\"20\":1}}],[\"或者构建比较复杂的数据\",{\"1\":{\"18\":1}}],[\"或者vo转化为entity\",{\"1\":{\"11\":1}}],[\"热点数据\",{\"1\":{\"18\":1}}],[\"会先判断key是否相同\",{\"1\":{\"66\":1}}],[\"会先判断定位到的数组位置有没有元素\",{\"1\":{\"66\":1}}],[\"会先进行下面这些权限判断\",{\"1\":{\"52\":1}}],[\"会有很多重复性的代码\",{\"1\":{\"48\":1}}],[\"会在前后分别加上帧头和帧尾\",{\"1\":{\"44\":1}}],[\"会加上一个ip头部传送给下一层\",{\"1\":{\"43\":1}}],[\"会加上tcp的头部传输给网络层\",{\"1\":{\"42\":1}}],[\"会进行一个拉取资源的操作\",{\"1\":{\"27\":1}}],[\"会直接返回给前端\",{\"1\":{\"22\":1}}],[\"会丢掉一部分之前的提交记录\",{\"1\":{\"16\":1}}],[\"会使feature的原基底都变了\",{\"1\":{\"16\":1}}],[\"会出现什么问题\",{\"1\":{\"3\":1}}],[\">=\",{\"1\":{\"116\":2,\"120\":4}}],[\">\",{\"1\":{\"88\":3,\"93\":2,\"101\":1}}],[\">1\",{\"1\":{\"78\":1}}],[\">null\",{\"1\":{\"78\":4}}],[\">5\",{\"1\":{\"78\":3}}],[\">4\",{\"1\":{\"78\":4}}],[\">3\",{\"1\":{\"78\":4}}],[\">2\",{\"1\":{\"78\":3}}],[\">d\",{\"1\":{\"16\":1}}],[\">c\",{\"1\":{\"16\":1}}],[\">b\",{\"1\":{\"16\":1}}],[\"想拉取master分支的最新代码合并到feature上\",{\"1\":{\"16\":1}}],[\"f\",{\"1\":{\"115\":1}}],[\"fast\",{\"1\":{\"108\":6}}],[\"false\",{\"1\":{\"107\":1,\"108\":2,\"111\":1,\"112\":2,\"115\":1,\"116\":3}}],[\"fill\",{\"1\":{\"73\":1}}],[\"find\",{\"1\":{\"116\":4}}],[\"findones\",{\"1\":{\"93\":1}}],[\"findmaxsize\",{\"1\":{\"84\":1}}],[\"findlongest\",{\"1\":{\"73\":1}}],[\"final类型的\",{\"1\":{\"57\":1}}],[\"for\",{\"1\":{\"73\":1,\"88\":1,\"93\":2,\"101\":2,\"116\":2}}],[\"forname\",{\"1\":{\"62\":2}}],[\"forever\",{\"1\":{\"4\":1}}],[\"feifei\",{\"1\":{\"60\":1,\"62\":1}}],[\"feature是待变基分支\",{\"1\":{\"16\":1}}],[\"feature是从master的某个节点处分离出来的一条分支\",{\"1\":{\"16\":1}}],[\"ftp文件传输协议\",{\"1\":{\"39\":1}}],[\"grid\",{\"1\":{\"92\":1,\"93\":14}}],[\"green\",{\"1\":{\"4\":1}}],[\"get\",{\"1\":{\"101\":1}}],[\"getname\",{\"1\":{\"62\":1}}],[\"getnamemethod\",{\"1\":{\"62\":2}}],[\"getmethod\",{\"1\":{\"62\":2}}],[\"getconstructor\",{\"1\":{\"62\":1}}],[\"get请求代表获取某个资源\",{\"1\":{\"40\":1}}],[\"git\",{\"2\":{\"17\":1}}],[\"git的rebase\",{\"0\":{\"16\":1}}],[\"基础语法\",{\"2\":{\"15\":1}}],[\"编译报错\",{\"1\":{\"13\":3}}],[\"编译器会报错\",{\"1\":{\"13\":1}}],[\"biginteger\",{\"1\":{\"119\":1}}],[\"bilibili\",{\"1\":{\"52\":1}}],[\"board\",{\"1\":{\"115\":2,\"116\":13}}],[\"boolean\",{\"1\":{\"108\":1,\"112\":1,\"116\":5}}],[\"before\",{\"1\":{\"52\":1}}],[\"before注解\",{\"1\":{\"49\":1}}],[\"b账户应该是300元\",{\"1\":{\"33\":1}}],[\"b\",{\"1\":{\"13\":4,\"87\":2,\"115\":1}}],[\"0\",{\"1\":{\"13\":2,\"73\":3,\"84\":5,\"87\":5,\"88\":6,\"92\":12,\"93\":10,\"101\":3,\"104\":5,\"107\":2,\"112\":1,\"116\":7,\"120\":9}}],[\"==\",{\"1\":{\"78\":1,\"84\":5,\"88\":5,\"93\":2,\"97\":1,\"108\":2,\"112\":4,\"116\":3,\"120\":1}}],[\"=\",{\"1\":{\"13\":6,\"53\":1,\"60\":1,\"62\":5,\"73\":8,\"77\":1,\"78\":10,\"84\":8,\"87\":3,\"88\":4,\"92\":1,\"93\":4,\"96\":1,\"97\":9,\"100\":4,\"101\":6,\"104\":21,\"107\":2,\"108\":8,\"111\":2,\"112\":7,\"115\":2,\"116\":10,\"119\":2,\"120\":8}}],[\"append\",{\"1\":{\"120\":2}}],[\"api\",{\"0\":{\"62\":1}}],[\"apilimitedroleaspect\",{\"1\":{\"52\":1}}],[\"apilimitedrole\",{\"1\":{\"51\":1,\"52\":4,\"53\":1}}],[\"alt\",{\"1\":{\"104\":1}}],[\"aslist\",{\"1\":{\"88\":1}}],[\"aspect\",{\"1\":{\"52\":1}}],[\"aspect实现\",{\"1\":{\"49\":1}}],[\"addtwonums\",{\"1\":{\"104\":1}}],[\"add\",{\"1\":{\"88\":1,\"97\":1,\"101\":1}}],[\"addusermoments\",{\"1\":{\"53\":1}}],[\"arraylist<>\",{\"1\":{\"88\":1,\"97\":1,\"101\":1}}],[\"arrays\",{\"1\":{\"73\":1,\"88\":2,\"101\":2}}],[\"ababc\",{\"1\":{\"72\":1,\"73\":1}}],[\"abcced\",{\"1\":{\"115\":1}}],[\"abc\",{\"1\":{\"72\":1,\"73\":1}}],[\"authroleconstant\",{\"1\":{\"53\":1}}],[\"autowired\",{\"1\":{\"52\":2}}],[\"annotation\",{\"1\":{\"52\":3}}],[\"aop使用的是两种动态代理\",{\"1\":{\"54\":1}}],[\"aop就是在某些方法前后执行一些通用的操作\",{\"1\":{\"49\":1}}],[\"aop的jdk动态代理中\",{\"1\":{\"61\":1}}],[\"aop的实现原理\",{\"0\":{\"54\":1}}],[\"aop的技术来实现\",{\"1\":{\"49\":1}}],[\"aop的\",{\"0\":{\"47\":1}}],[\"a账户应该是100元\",{\"1\":{\"33\":1}}],[\"a向b转账100元\",{\"1\":{\"32\":1}}],[\"a\",{\"1\":{\"13\":4,\"87\":2,\"115\":2}}],[\"都需要先判断权限\",{\"1\":{\"49\":1}}],[\"都需要数据库表中的所有字段\",{\"1\":{\"11\":1}}],[\"都是错的\",{\"1\":{\"13\":1}}],[\"d\",{\"1\":{\"115\":1}}],[\"dummy\",{\"1\":{\"104\":3}}],[\"dfs\",{\"1\":{\"84\":4,\"93\":6,\"116\":6},\"2\":{\"94\":1}}],[\"datalimited\",{\"1\":{\"53\":1}}],[\"default\",{\"1\":{\"51\":1}}],[\"dobefore\",{\"1\":{\"52\":1}}],[\"domain\",{\"1\":{\"52\":1}}],[\"documented\",{\"1\":{\"51\":1}}],[\"document\",{\"1\":{\"51\":1}}],[\"double\",{\"1\":{\"13\":2}}],[\"double类型的值可以赋给long变量吗\",{\"0\":{\"13\":1},\"1\":{\"13\":1}}],[\"dns域名解析服务\",{\"1\":{\"39\":1}}],[\"dto是数据传输对象\",{\"1\":{\"11\":1}}],[\"dto\",{\"0\":{\"11\":1}}],[\"项目中需要对前端的元素\",{\"1\":{\"48\":1}}],[\"项目\",{\"2\":{\"30\":1}}],[\"项目规范\",{\"2\":{\"12\":1}}],[\"项目设计\",{\"2\":{\"9\":1}}],[\"过程中需要的中间对象\",{\"1\":{\"11\":1}}],[\"技术选型\",{\"2\":{\"10\":1}}],[\"m\",{\"1\":{\"115\":1,\"116\":3,\"120\":2}}],[\"max\",{\"1\":{\"73\":2,\"84\":6}}],[\"math\",{\"1\":{\"73\":2,\"84\":2}}],[\"map中的数据是以\",{\"1\":{\"65\":1}}],[\"master是基分支\",{\"1\":{\"16\":1}}],[\"mybatis框架\",{\"1\":{\"61\":1}}],[\"moments\",{\"1\":{\"53\":1}}],[\"mq\",{\"2\":{\"10\":1}}],[\"method\",{\"1\":{\"51\":1,\"62\":2}}],[\"me\",{\"0\":{\"0\":1}}],[\"r\",{\"1\":{\"88\":12}}],[\"rightsize\",{\"1\":{\"84\":3}}],[\"right\",{\"1\":{\"84\":7,\"97\":6,\"112\":7}}],[\"root\",{\"1\":{\"84\":10,\"96\":2,\"97\":3,\"111\":2,\"112\":9}}],[\"role\",{\"1\":{\"53\":1}}],[\"rocketmq\",{\"1\":{\"7\":1}}],[\"runtime\",{\"1\":{\"51\":1}}],[\"reverse\",{\"1\":{\"78\":1,\"120\":1}}],[\"res++\",{\"1\":{\"93\":1}}],[\"res\",{\"1\":{\"73\":4,\"88\":5,\"93\":2,\"97\":4,\"101\":3,\"120\":4}}],[\"return\",{\"1\":{\"53\":1,\"73\":1,\"78\":2,\"84\":4,\"88\":3,\"93\":2,\"97\":2,\"101\":1,\"104\":1,\"108\":3,\"112\":5,\"116\":4,\"120\":1}}],[\"retentionpolicy\",{\"1\":{\"51\":1}}],[\"retention\",{\"1\":{\"51\":2}}],[\"requestbody\",{\"1\":{\"53\":1}}],[\"redis\",{\"2\":{\"23\":1}}],[\"rebase\",{\"1\":{\"16\":2}}],[\"rabbitmq的性能也还行\",{\"1\":{\"8\":1}}],[\"金融的项目\",{\"1\":{\"8\":1}}],[\"互联网\",{\"1\":{\"8\":1}}],[\"高效\",{\"1\":{\"43\":1}}],[\"高并发\",{\"1\":{\"8\":1}}],[\"高中二年级时\",{\"1\":{\"1\":1}}],[\"天猫双十一流量高峰的考验\",{\"1\":{\"8\":1}}],[\"历经淘宝\",{\"1\":{\"8\":1}}],[\"增加和减少功能\",{\"1\":{\"7\":1}}],[\"弹幕推送也会用到用户的消息\",{\"1\":{\"7\":1}}],[\"可劲搜\",{\"1\":{\"93\":1}}],[\"可维护性不高\",{\"1\":{\"48\":1}}],[\"可以定义一个boolean类型的数值来标记是否找到\",{\"1\":{\"116\":1}}],[\"可以通过连续跟踪\",{\"1\":{\"107\":1}}],[\"可以维护一个int类型的变量index\",{\"1\":{\"104\":1}}],[\"可以先把两个数组进行排序\",{\"1\":{\"101\":1}}],[\"可以不考虑输出结果的顺序\",{\"1\":{\"100\":1}}],[\"可以向左搜索\",{\"1\":{\"93\":1}}],[\"可以固定一个数字\",{\"1\":{\"88\":1}}],[\"可以声明一个数组\",{\"1\":{\"73\":1}}],[\"可以想到滑动窗口\",{\"1\":{\"73\":1}}],[\"可以获取一个类中所有的属性和方法\",{\"1\":{\"61\":1}}],[\"可以用快慢指针\",{\"1\":{\"108\":1}}],[\"可以用\",{\"1\":{\"49\":1}}],[\"可以用git\",{\"1\":{\"16\":1}}],[\"可以设置互斥锁\",{\"1\":{\"20\":1}}],[\"可以处理得慢一点\",{\"1\":{\"7\":1}}],[\"可靠性也很强\",{\"1\":{\"8\":1}}],[\"可能是恶意请求\",{\"1\":{\"22\":1}}],[\"可能会存在哈希碰撞的问题\",{\"1\":{\"22\":1}}],[\"可能会有宕机的风险\",{\"1\":{\"19\":1}}],[\"可能会上云\",{\"1\":{\"3\":1}}],[\"可能要复制队列\",{\"1\":{\"7\":1}}],[\"可能要用到大数据和人工智能来解决瓶颈\",{\"1\":{\"3\":1}}],[\"可能还需要掌握其他知识\",{\"1\":{\"3\":1}}],[\"二维矩阵\",{\"2\":{\"117\":1}}],[\"二维字符网格\",{\"1\":{\"115\":1}}],[\"二叉树的前序遍历\",{\"0\":{\"96\":1}}],[\"二叉树的直径是指两个节点之间的最大距离\",{\"1\":{\"82\":1}}],[\"二叉树的直径\",{\"0\":{\"81\":1}}],[\"二叉树\",{\"2\":{\"85\":1,\"98\":1,\"113\":1}}],[\"二是最后返回是否找到这个单词\",{\"1\":{\"116\":1}}],[\"二是因为位置多了\",{\"1\":{\"67\":1}}],[\"二是向ca申请数字证书\",{\"1\":{\"41\":1}}],[\"二是长连接\",{\"1\":{\"28\":1}}],[\"二是java也确实很流行\",{\"1\":{\"2\":1}}],[\"二\",{\"0\":{\"52\":1},\"1\":{\"22\":1}}],[\"二又可以削峰\",{\"1\":{\"7\":1}}],[\"又包含视频等\",{\"1\":{\"40\":1}}],[\"又会从数据库中查询出所有的弹幕\",{\"1\":{\"7\":1}}],[\"又为什么选择了java后端\",{\"1\":{\"0\":1}}],[\"系统会将关于这个视频的所有弹幕\",{\"1\":{\"7\":1}}],[\"多个消费者可以订阅这个主题进行消费\",{\"1\":{\"7\":1}}],[\"生产者可以将消息推送到这个主题中\",{\"1\":{\"7\":1}}],[\"的路径\",{\"1\":{\"111\":1}}],[\"的方式存储的\",{\"1\":{\"104\":1}}],[\"的链表\",{\"1\":{\"104\":1}}],[\"的三元组\",{\"1\":{\"87\":1}}],[\"的长度\",{\"1\":{\"72\":1,\"82\":1}}],[\"的形式存储的\",{\"1\":{\"65\":1}}],[\"的情况\",{\"1\":{\"32\":1}}],[\"的事儿\",{\"1\":{\"7\":1}}],[\"的概念\",{\"1\":{\"7\":1}}],[\"的梦想\",{\"1\":{\"1\":1}}],[\"主流的消息队列有很多\",{\"1\":{\"7\":1}}],[\"主题\",{\"1\":{\"7\":1}}],[\"主要考虑有以下几点\",{\"1\":{\"7\":1}}],[\"在向栈中push元素的时候\",{\"1\":{\"97\":1}}],[\"在向数据库写入数据的时候\",{\"1\":{\"22\":1}}],[\"在dfs搜索之前\",{\"1\":{\"93\":1}}],[\"在put元素的时候\",{\"1\":{\"66\":1}}],[\"在查找的时候\",{\"1\":{\"65\":1}}],[\"在这种情况下\",{\"1\":{\"60\":1}}],[\"在这个过程中\",{\"1\":{\"49\":1}}],[\"在注解最上面用了一个\",{\"1\":{\"54\":1}}],[\"在调用controller层时的接口时\",{\"1\":{\"52\":1}}],[\"在aop中\",{\"1\":{\"49\":1}}],[\"在四次握手之后还要进行ssl\",{\"1\":{\"41\":1}}],[\"在三次握手之后就直接传输数据\",{\"1\":{\"41\":1}}],[\"在视频列表点进自己感兴趣的视频\",{\"1\":{\"26\":1}}],[\"在web应用请求查询的时候\",{\"1\":{\"22\":1}}],[\"在布隆过滤器上做个标记\",{\"1\":{\"22\":1}}],[\"在redis里缓存一个空值或者默认值\",{\"1\":{\"22\":1}}],[\"在rocketmq中有\",{\"1\":{\"7\":1}}],[\"在feature分支开发一段时间后\",{\"1\":{\"16\":1}}],[\"在不进行强制转换的情况下\",{\"1\":{\"13\":1}}],[\"在学校的软件实验室接过一个项目\",{\"1\":{\"7\":1}}],[\"是指没有子节点的节点\",{\"1\":{\"111\":1}}],[\"是先获取key对象的hashcode值\",{\"1\":{\"66\":1}}],[\"是继承实现的\",{\"1\":{\"54\":1}}],[\"是在controller层的接口直接加上一个注解\",{\"1\":{\"50\":1}}],[\"是需要根据具体业务场景来判断的\",{\"1\":{\"28\":1}}],[\"是用来将entity转换为vo\",{\"1\":{\"11\":1}}],[\"是选择消息队列的一个重要原因\",{\"1\":{\"7\":1}}],[\"是一个商业性的视频弹幕系统\",{\"1\":{\"7\":1}}],[\"订阅模式\",{\"1\":{\"7\":1}}],[\"关注和弹幕推送选择了消息队列来实现\",{\"1\":{\"7\":1}}],[\"选择了fastdfs分布式文件存储\",{\"1\":{\"7\":1}}],[\"因为选择其他位置再次寻找\",{\"1\":{\"116\":1}}],[\"因为是把targetsum作为参数整体传进去的\",{\"1\":{\"112\":1}}],[\"因为是基于内存的数据库\",{\"1\":{\"18\":1}}],[\"因为快指针每次要往后移动两步\",{\"1\":{\"108\":1}}],[\"因为要有输出链表\",{\"1\":{\"104\":1}}],[\"因为队列是先进后出\",{\"1\":{\"97\":1}}],[\"因为dfs不论有没有搜到\",{\"1\":{\"93\":1}}],[\"因为二叉树本身就是一个递归的结构\",{\"1\":{\"83\":1}}],[\"因为不写切点\",{\"1\":{\"52\":1}}],[\"因为不是所有的接口\",{\"1\":{\"11\":1}}],[\"因为网络之间的传输过程是错综复杂的\",{\"1\":{\"43\":1}}],[\"因为布隆过滤器底层是由位图数组和哈希算法实现的\",{\"1\":{\"22\":1}}],[\"因为消息队列的机制\",{\"1\":{\"7\":1}}],[\"因为考虑到大存储量和用户量\",{\"1\":{\"7\":1}}],[\"因为我想探索出自己擅长的\",{\"1\":{\"2\":1}}],[\"点赞关注和弹幕推送等功能\",{\"1\":{\"7\":1}}],[\"幻灯片页\",{\"0\":{\"5\":1}}],[\"young\",{\"1\":{\"4\":1}}],[\"把自己姓名发送到火星上\",{\"1\":{\"4\":1}}],[\"把产品做好\",{\"1\":{\"3\":1}}],[\"表示两个非负的整数\",{\"1\":{\"104\":1}}],[\"表示切点的应用范围\",{\"1\":{\"52\":1}}],[\"表示会被spring进行管理\",{\"1\":{\"51\":1}}],[\"表示这个注解会被加到doc文档上\",{\"1\":{\"51\":1}}],[\"表示这个注解要加在方法上\",{\"1\":{\"51\":1}}],[\"表示运行期间一直存在\",{\"1\":{\"51\":1}}],[\"表示\",{\"1\":{\"4\":1}}],[\"j+1\",{\"1\":{\"93\":1,\"116\":1}}],[\"j++\",{\"1\":{\"93\":1,\"101\":2,\"116\":1}}],[\"j\",{\"1\":{\"93\":12,\"101\":4,\"116\":13,\"120\":5}}],[\"jsonresponse\",{\"1\":{\"53\":1}}],[\"jsonresponse<string>\",{\"1\":{\"53\":1}}],[\"joinpoint\",{\"1\":{\"52\":2}}],[\"jim\",{\"1\":{\"4\":1}}],[\"java\",{\"0\":{\"124\":1}}],[\"java基础\",{\"1\":{\"3\":1},\"2\":{\"14\":1,\"58\":1,\"63\":1,\"69\":1}}],[\"java或许不会永远流行\",{\"1\":{\"2\":1}}],[\"星球科学总监\",{\"1\":{\"4\":1}}],[\"最后输出链表存储的数字也是逆序的\",{\"1\":{\"104\":1}}],[\"最后都是一个岛屿\",{\"1\":{\"93\":1}}],[\"最后return\",{\"1\":{\"78\":1}}],[\"最后我们为什么采用websocket协议\",{\"1\":{\"28\":1}}],[\"最长子串\",{\"1\":{\"72\":1}}],[\"最常见的是这样的\",{\"1\":{\"60\":1}}],[\"最为明显的是弹幕推送功能\",{\"1\":{\"7\":1}}],[\"最高处见\",{\"1\":{\"3\":1}}],[\"最近也想了想自己想加入什么样的团队\",{\"1\":{\"2\":1}}],[\"最近在找日常实习的时候\",{\"1\":{\"0\":1}}],[\"22\",{\"1\":{\"111\":1}}],[\"2<\",{\"1\":{\"78\":2}}],[\"2\",{\"0\":{\"76\":1},\"1\":{\"77\":2,\"78\":1,\"82\":3,\"87\":2,\"96\":2,\"100\":6,\"104\":1,\"107\":1,\"111\":1}}],[\"20岁的我没有让你失望\",{\"1\":{\"3\":1}}],[\"2年之后\",{\"1\":{\"3\":1}}],[\"2年内\",{\"1\":{\"3\":1}}],[\"支撑着我前进\",{\"1\":{\"3\":1}}],[\"谢谢你的梦想\",{\"1\":{\"3\":1}}],[\"中等\",{\"2\":{\"90\":1,\"105\":1,\"118\":1}}],[\"中是否存在三个元素\",{\"1\":{\"87\":1}}],[\"中间件\",{\"1\":{\"3\":1}}],[\"中学时代\",{\"1\":{\"0\":1}}],[\"结合工作实际负责的业务或者兴趣\",{\"1\":{\"3\":1}}],[\"工作1\",{\"1\":{\"3\":1}}],[\"工作半年之后\",{\"1\":{\"3\":1}}],[\"学习对工作最有用的技术\",{\"1\":{\"3\":1}}],[\"学会了追逐梦想\",{\"1\":{\"0\":1}}],[\"针对不断变化的业务场景和数据量\",{\"1\":{\"3\":1}}],[\"产品意识\",{\"1\":{\"3\":1}}],[\"当需要存储元素的时候\",{\"1\":{\"67\":1}}],[\"当传输数据+tcp头+ip头传输到网络接口层时\",{\"1\":{\"44\":1}}],[\"当传输数据+tcp头部传到网络层时\",{\"1\":{\"43\":1}}],[\"当线上发现发生缓存穿透的问题\",{\"1\":{\"22\":1}}],[\"当web应用触发请求\",{\"1\":{\"19\":1,\"21\":1}}],[\"当数据量达到一定数量级后\",{\"1\":{\"18\":1}}],[\"当然除了基础能力\",{\"1\":{\"3\":1}}],[\"当我大声说出梦想的时候\",{\"1\":{\"0\":1}}],[\"能够通过哈希函数将key映射到哈希表中的一个索引位置\",{\"1\":{\"65\":1}}],[\"能够在运行时分析类以及执行类中方法\",{\"1\":{\"61\":1}}],[\"能够保证消息的可靠性\",{\"1\":{\"28\":1}}],[\"能够根据需求去独立完成有意义的模块\",{\"1\":{\"3\":1}}],[\"能够很快给人以正反馈\",{\"1\":{\"2\":1}}],[\"能否让自己的工作变得challenging\",{\"1\":{\"3\":1}}],[\"自己也可以发送一条弹幕\",{\"1\":{\"26\":1}}],[\"自己需要对后端的某个特定领域有一定程序的深挖和积累\",{\"1\":{\"3\":1}}],[\"自己要做到对于业务有足够多的理解\",{\"1\":{\"3\":1}}],[\"自己能不能尝试改一改去保证更高的质量\",{\"1\":{\"3\":1}}],[\"自己热爱的\",{\"1\":{\"2\":1}}],[\"依赖的上游有没有一些潜在的问题\",{\"1\":{\"3\":1}}],[\"哪个模块最有用\",{\"1\":{\"3\":1}}],[\"哪怕很简单\",{\"1\":{\"0\":1}}],[\"受众是谁\",{\"1\":{\"3\":1}}],[\"比如\",{\"1\":{\"119\":1}}],[\"比如下面这颗树\",{\"1\":{\"82\":1}}],[\"比如下面这两种写法\",{\"1\":{\"13\":1}}],[\"比如原链表是1\",{\"1\":{\"78\":1}}],[\"比如遍历\",{\"1\":{\"73\":1}}],[\"比如从类名上可以看出所属关系\",{\"1\":{\"57\":1}}],[\"比如单例模式\",{\"1\":{\"54\":1}}],[\"比如日志操作\",{\"1\":{\"49\":1}}],[\"比如为某篇文章添加评论\",{\"1\":{\"40\":1}}],[\"比如html就是一个常见的超文本\",{\"1\":{\"40\":1}}],[\"比如http超文本传输协议\",{\"1\":{\"39\":1}}],[\"比如我们找到第一个\",{\"1\":{\"93\":1}}],[\"比如我们打开一个网页\",{\"1\":{\"40\":1}}],[\"比如我们点开一个视频\",{\"1\":{\"7\":1}}],[\"比如手机上的软件都是在应用层实现的\",{\"1\":{\"39\":1}}],[\"比如a账户和b账户原来余额都是200元\",{\"1\":{\"33\":1}}],[\"比如经典的转账案例\",{\"1\":{\"32\":1}}],[\"比如缓存雪崩\",{\"1\":{\"18\":1}}],[\"比如master分支上在b节点后新开发了m\",{\"1\":{\"16\":1}}],[\"比如说feature是master节点b处拉出来的一条新分支\",{\"1\":{\"16\":1}}],[\"比如rabbitmq\",{\"1\":{\"7\":1}}],[\"比如关注完\",{\"1\":{\"7\":1}}],[\"比如关注功能会用到这个用户的信息\",{\"1\":{\"7\":1}}],[\"比如可能会转golang\",{\"1\":{\"3\":1}}],[\"比如这个模块为什么这么设计\",{\"1\":{\"3\":1}}],[\"比如数据库\",{\"1\":{\"3\":2}}],[\"134\",{\"1\":{\"119\":1}}],[\"13\",{\"1\":{\"111\":1}}],[\"11\",{\"0\":{\"107\":1},\"1\":{\"111\":1,\"119\":1}}],[\"10\",{\"0\":{\"115\":1},\"1\":{\"104\":2,\"120\":2}}],[\"1000\",{\"1\":{\"100\":1}}],[\"123\",{\"1\":{\"119\":1}}],[\"12\",{\"0\":{\"96\":1}}],[\"128\",{\"1\":{\"73\":1}}],[\"1<\",{\"1\":{\"78\":2}}],[\"1\",{\"0\":{\"71\":1},\"1\":{\"3\":1,\"13\":4,\"52\":1,\"67\":1,\"73\":4,\"77\":2,\"78\":2,\"82\":3,\"84\":2,\"87\":7,\"88\":4,\"92\":11,\"93\":12,\"96\":2,\"100\":3,\"107\":1,\"111\":1,\"116\":3,\"120\":3}}],[\"1吧哈哈\",{\"1\":{\"3\":1}}],[\"争取拿到领域内的no\",{\"1\":{\"3\":1}}],[\"做出对社会有积极意义的产品\",{\"1\":{\"3\":1}}],[\"做出好的产品\",{\"1\":{\"2\":1}}],[\"至于长远的职业发展\",{\"1\":{\"3\":1}}],[\"至少我确定了我不擅长硬件\",{\"1\":{\"2\":1}}],[\"以body的形式通过tcp协议存到服务器中\",{\"1\":{\"40\":1}}],[\"以http协议举例\",{\"0\":{\"40\":1}}],[\"以及上份实习为什么离职\",{\"1\":{\"2\":1}}],[\"以至于在其他教学楼上课的学生都听到了\",{\"1\":{\"0\":1}}],[\"语言之间的转换也不难\",{\"1\":{\"2\":1}}],[\"要注意如何进位\",{\"1\":{\"120\":1}}],[\"要注意收集结果的时机\",{\"1\":{\"97\":1}}],[\"要再标记成未访问\",{\"1\":{\"116\":1}}],[\"要求根节点到叶子节点这条路径上的节点之和\",{\"1\":{\"112\":1}}],[\"要先push右子树\",{\"1\":{\"97\":1}}],[\"要么全部不发生\",{\"1\":{\"32\":1}}],[\"要么全部发生\",{\"1\":{\"32\":1}}],[\"要么等待锁释放后重新读取缓存\",{\"1\":{\"20\":1}}],[\"要么返回空值或者默认值\",{\"1\":{\"20\":1}}],[\"要拉取master最新的代码合到feature上\",{\"1\":{\"16\":1}}],[\"要思考\",{\"1\":{\"2\":1}}],[\"要做好转语言的准备\",{\"1\":{\"2\":1}}],[\"要从高中二年级开始\",{\"1\":{\"0\":1}}],[\"社会和公司的业务是不断变化的\",{\"1\":{\"2\":1}}],[\"三数之和\",{\"0\":{\"87\":1}}],[\"三\",{\"0\":{\"53\":1},\"1\":{\"2\":1,\"22\":1}}],[\"让我觉得我真的能用java做出对社会有积极意义的产品\",{\"1\":{\"2\":1}}],[\"让我知道了梦想的力量\",{\"1\":{\"0\":1}}],[\"很多人也夸你优秀\",{\"1\":{\"3\":1}}],[\"很多公司都有java相关的岗位\",{\"1\":{\"2\":1}}],[\"很简单\",{\"1\":{\"2\":1}}],[\"去重逻辑\",{\"1\":{\"88\":1}}],[\"去自己造而已\",{\"1\":{\"2\":1}}],[\"去模仿\",{\"1\":{\"2\":1}}],[\"去思考为什么\",{\"1\":{\"2\":1}}],[\"觉得自己被否定\",{\"1\":{\"3\":1}}],[\"觉得自己好像找到和自己灵魂相通的方向了一样\",{\"1\":{\"2\":1}}],[\"觉得很满足\",{\"1\":{\"2\":1}}],[\"对数据库的影响应该是永久的\",{\"1\":{\"35\":1}}],[\"对于hashcode的高位和低位\",{\"1\":{\"66\":1}}],[\"对于弹幕模块\",{\"1\":{\"28\":1}}],[\"对于获取弹幕功能\",{\"1\":{\"27\":1}}],[\"对于一些非法的请求进行拦截判断\",{\"1\":{\"22\":1}}],[\"对于用户经常访问的数据\",{\"1\":{\"18\":1}}],[\"对于后端数据库是两次的io处理\",{\"1\":{\"7\":1}}],[\"对应实际需要传输的字段\",{\"1\":{\"11\":1}}],[\"对应数据库表中的字段和属性\",{\"1\":{\"11\":1}}],[\"对性能有一定的要求\",{\"1\":{\"7\":1}}],[\"对自己说\",{\"1\":{\"3\":1}}],[\"对社会有积极意义的\",{\"1\":{\"2\":1}}],[\"对物理也并不擅长\",{\"1\":{\"1\":1}}],[\"这条路径上所有节点值相加等于目标和\",{\"1\":{\"111\":1}}],[\"这条弹幕也会推送到所有在线看到视频的用户\",{\"1\":{\"26\":1}}],[\"这两个数都不会以\",{\"1\":{\"104\":1}}],[\"这不就是dfs的算法吗\",{\"1\":{\"93\":1}}],[\"这一步是毫无疑问的\",{\"1\":{\"93\":1}}],[\"这一瞬间大量请求就会打到数据库\",{\"1\":{\"19\":1}}],[\"这其实就是反射的特点\",{\"1\":{\"60\":1}}],[\"这里指发挥作用的注解具体是哪一个\",{\"1\":{\"52\":1}}],[\"这里是runtime\",{\"1\":{\"51\":1}}],[\"这些协议在应用层专注为用户提供协议\",{\"1\":{\"40\":1}}],[\"这些都是需要在工作中不断思考\",{\"1\":{\"3\":1}}],[\"这又是对资源的浪费\",{\"1\":{\"27\":1}}],[\"这就是短连接的过程\",{\"1\":{\"27\":1}}],[\"这就是我转入计算机专业的原因\",{\"1\":{\"2\":1}}],[\"这种现象的原因就是\",{\"1\":{\"22\":1}}],[\"这时候大量请求又请求数据库\",{\"1\":{\"21\":1}}],[\"这时候需要把feature上的提交暂存下来\",{\"1\":{\"16\":1}}],[\"这个函数隐含着回溯的细节\",{\"1\":{\"112\":1}}],[\"这个最大值是\",{\"1\":{\"83\":1}}],[\"这个temp是用来cur指针下一步遍历的\",{\"1\":{\"78\":1}}],[\"这个计算hash值的过程是比较耗时的\",{\"1\":{\"68\":1}}],[\"这个我们自己定义的注解就成了spring管理的一个bean对象\",{\"1\":{\"54\":1}}],[\"这个注解是我们自定义的\",{\"1\":{\"50\":1}}],[\"这个封装成的类\",{\"1\":{\"49\":1}}],[\"这个可以\",{\"1\":{\"13\":1}}],[\"这个值也不能赋给long变量\",{\"1\":{\"13\":1}}],[\"这个过程中\",{\"1\":{\"3\":1}}],[\"这是为什么采用消息队列的思考\",{\"1\":{\"7\":1}}],[\"这是\",{\"1\":{\"7\":1}}],[\"这是我初中印象最深刻的一刻\",{\"1\":{\"0\":1}}],[\"这是我第一次告诉大家我的梦想\",{\"1\":{\"0\":1}}],[\"这对资源是一种损耗\",{\"1\":{\"7\":1}}],[\"这也许也是让我觉得自己热爱的原因之一\",{\"1\":{\"2\":1}}],[\"不要忘记移动指针\",{\"1\":{\"120\":1}}],[\"不要忘了16岁自己的梦想\",{\"1\":{\"0\":1}}],[\"不作为参数进行传递\",{\"1\":{\"107\":1}}],[\"不难写出以下代码\",{\"1\":{\"93\":1}}],[\"不到黄河不回头\",{\"1\":{\"93\":1}}],[\"不重复\",{\"1\":{\"87\":1}}],[\"不一定经过根节点\",{\"1\":{\"82\":1}}],[\"不含重复字符和最长子串\",{\"1\":{\"73\":1}}],[\"不断put元素进去\",{\"1\":{\"67\":1}}],[\"不断反思\",{\"1\":{\"3\":1}}],[\"不能被修改\",{\"1\":{\"57\":1}}],[\"不知道应用范围\",{\"1\":{\"52\":1}}],[\"不用写大量重复性的代码\",{\"1\":{\"49\":1}}],[\"不安全\",{\"1\":{\"41\":1}}],[\"不会出现只执行一半\",{\"1\":{\"32\":1}}],[\"不给热点数据设置过期时间\",{\"1\":{\"20\":1}}],[\"不可以\",{\"1\":{\"13\":1}}],[\"不利于做二次开发和维护\",{\"1\":{\"8\":1}}],[\"不管弹幕推送和视频推送怎样处理\",{\"1\":{\"7\":1}}],[\"不至于发生阻塞让用户长时间等待\",{\"1\":{\"7\":1}}],[\"不也一样很好吗\",{\"1\":{\"2\":1}}],[\"就统计+1\",{\"1\":{\"93\":1}}],[\"就跳出搜索\",{\"1\":{\"93\":1}}],[\"就计算这个字符下标之后的长度即\",{\"1\":{\"73\":1}}],[\"就判断当前节点是否是一个树节点\",{\"1\":{\"66\":1}}],[\"就知道这是一个什么样的类的前提下\",{\"1\":{\"60\":1}}],[\"就能实现权限判断\",{\"1\":{\"50\":1}}],[\"就一定相遇\",{\"1\":{\"108\":1}}],[\"就一定不存在\",{\"1\":{\"22\":1}}],[\"就一定能做好\",{\"1\":{\"2\":1}}],[\"就无法构建缓存\",{\"1\":{\"21\":1}}],[\"就去数据库中请求数据\",{\"1\":{\"19\":1,\"21\":1}}],[\"就像一个滑动的窗口\",{\"1\":{\"73\":1}}],[\"就像任何操作没有进行的样子\",{\"1\":{\"32\":1}}],[\"就像关注功能\",{\"1\":{\"7\":1}}],[\"就像php一样\",{\"1\":{\"2\":1}}],[\"就是http的get请求\",{\"1\":{\"40\":1}}],[\"就是\",{\"1\":{\"1\":1}}],[\"就是上本地最好的高中\",{\"1\":{\"0\":1}}],[\"那终止条件是什么呢\",{\"1\":{\"108\":1}}],[\"那知道怎么搜之后\",{\"1\":{\"93\":1}}],[\"那我们如何找到水平方向和竖直方向上是否有连接的陆地\",{\"1\":{\"93\":1}}],[\"那整个组肯定不满足要求\",{\"1\":{\"88\":1}}],[\"那最大值怎么维护\",{\"1\":{\"83\":1}}],[\"那就是cglib动态代理类\",{\"1\":{\"54\":1}}],[\"那就是jdk代理类\",{\"1\":{\"54\":1}}],[\"那就试试软件嘛\",{\"1\":{\"1\":1}}],[\"那么我们可以采用双指针的解法\",{\"1\":{\"78\":1}}],[\"那么是如何判断key是否相同的呢\",{\"1\":{\"66\":1}}],[\"那么是如何应用代理模式的呢\",{\"1\":{\"54\":1}}],[\"那么什么是动态代理\",{\"1\":{\"54\":1}}],[\"那么spring在创建这个bean的时候\",{\"1\":{\"54\":1}}],[\"那么websocket协议对比http协议的优势在哪呢\",{\"1\":{\"28\":1}}],[\"那么其中一个解决方案就是\",{\"1\":{\"20\":1}}],[\"那个颤抖得几乎都要哭出来却又很坚定的声音和一往无前的气势\",{\"1\":{\"0\":1}}],[\"既然底层电路这些我做不来\",{\"1\":{\"1\":1}}],[\"甚至有点儿痛苦\",{\"1\":{\"1\":1}}],[\"但我想试试\",{\"1\":{\"2\":1}}],[\"但我对物理是真的不擅长\",{\"1\":{\"1\":1}}],[\"但是三元组里面的数字是可以重复的\",{\"1\":{\"88\":1}}],[\"但是cur再向后遍历时候\",{\"1\":{\"78\":1}}],[\"但是这个过程中有个问题\",{\"1\":{\"78\":1}}],[\"但是这是在我们一开始\",{\"1\":{\"60\":1}}],[\"但是value可以重复\",{\"1\":{\"65\":1}}],[\"但是能实现多个接口\",{\"1\":{\"57\":1}}],[\"但是浏览器的本身会进行限制\",{\"1\":{\"40\":1}}],[\"但是b账户没有增加\",{\"1\":{\"32\":1}}],[\"但是易于拓展\",{\"1\":{\"28\":1}}],[\"但是并不是说websocket协议就一定优于http协议\",{\"1\":{\"28\":1}}],[\"但是\",{\"1\":{\"27\":1}}],[\"但是如果操作1结束后的瞬间\",{\"1\":{\"32\":1}}],[\"但是如果判断存在\",{\"1\":{\"22\":1}}],[\"但是如果一个生产者对应多个消费者\",{\"1\":{\"7\":1}}],[\"但是可能有精度问题\",{\"1\":{\"22\":1}}],[\"但是使用缓存又会产生一些问题\",{\"1\":{\"18\":1}}],[\"但是有一点劣势是消息可能会重复消费\",{\"1\":{\"8\":1}}],[\"但是erlang语言本身有并发的优势\",{\"1\":{\"8\":1}}],[\"但是rabbitmq是基于erlang开发的\",{\"1\":{\"8\":1}}],[\"但是吞吐量比rocketmq和kafka低一个数量级\",{\"1\":{\"8\":1}}],[\"但是不能把服务器打挂\",{\"1\":{\"7\":1}}],[\"但是不要盲目\",{\"1\":{\"0\":1}}],[\"但是一切都在向好的方向发展\",{\"1\":{\"3\":1}}],[\"但是自己确实是能够做好的\",{\"1\":{\"2\":1}}],[\"但是看到它运行起来的那一刻\",{\"1\":{\"2\":1}}],[\"但是我喜欢程序世界\",{\"1\":{\"1\":1}}],[\"但是我还是选择了自动化专业\",{\"1\":{\"1\":1}}],[\"但是都会有意无意\",{\"1\":{\"0\":1}}],[\"但是还是想要把我的故事记录下来\",{\"1\":{\"0\":1}}],[\"虽然不是那么容易\",{\"1\":{\"2\":1}}],[\"虽然一开始学c语言的时候确实很痛苦\",{\"1\":{\"2\":1}}],[\"虽然我也并不确定我转到软件方向\",{\"1\":{\"2\":1}}],[\"虽然后来发现\",{\"1\":{\"1\":1}}],[\"虽然高考成绩自己并不满意\",{\"1\":{\"1\":1}}],[\"老师等等渠道了解这个专业的就业方向\",{\"1\":{\"1\":1}}],[\"家长\",{\"1\":{\"1\":1}}],[\"被录取这个专业后\",{\"1\":{\"1\":1}}],[\"假大空\",{\"1\":{\"1\":1}}],[\"一位\",{\"1\":{\"104\":1}}],[\"一层一层遍历\",{\"1\":{\"97\":1}}],[\"一旦遍历到一个\",{\"1\":{\"93\":1}}],[\"一开始\",{\"1\":{\"78\":1}}],[\"一种是cglib的动态代理\",{\"1\":{\"54\":1}}],[\"一种是jdk的动态代理\",{\"1\":{\"54\":1}}],[\"一共是400元\",{\"1\":{\"33\":1}}],[\"一致性\",{\"0\":{\"33\":1}}],[\"一致性是最终达成的目的\",{\"1\":{\"31\":1}}],[\"一是字母不允许被重复使用\",{\"1\":{\"116\":1}}],[\"一是能存储的元素更多了\",{\"1\":{\"67\":1}}],[\"一是ssl\",{\"1\":{\"41\":1}}],[\"一是全双工通信\",{\"1\":{\"28\":1}}],[\"一是java的学习路线很友好\",{\"1\":{\"2\":1}}],[\"一\",{\"0\":{\"51\":1},\"1\":{\"22\":1}}],[\"一次前端请求\",{\"1\":{\"7\":1}}],[\"一个在数组尾处\",{\"1\":{\"88\":1}}],[\"一个在i+1处\",{\"1\":{\"88\":1}}],[\"一个是不重复的三元组\",{\"1\":{\"88\":1}}],[\"一个是和为0的三元组\",{\"1\":{\"88\":1}}],[\"一个cur指针从head开始往后遍历原链表\",{\"1\":{\"78\":1}}],[\"一个pre指针指向head的前一位\",{\"1\":{\"78\":1}}],[\"一个元素占一个索引\",{\"1\":{\"67\":1}}],[\"一个类实现某个接口也就拥有了对应的行为\",{\"1\":{\"57\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"57\":1}}],[\"一个事务执行完毕后\",{\"1\":{\"35\":1}}],[\"一个事务执行前后\",{\"1\":{\"33\":1}}],[\"一个事务中的所有操作\",{\"1\":{\"32\":1}}],[\"一个feature分支\",{\"1\":{\"16\":1}}],[\"一个master分支\",{\"1\":{\"16\":1}}],[\"一个被关注者对应多个关注者\",{\"1\":{\"7\":1}}],[\"一个生产者对应一个消费者\",{\"1\":{\"7\":1}}],[\"一个队列中\",{\"1\":{\"7\":1}}],[\"一个优秀的工程师也不应该不看具体业务场景去死抠一门语言\",{\"1\":{\"2\":1}}],[\"一直搜\",{\"1\":{\"116\":1}}],[\"一直不断地探索\",{\"1\":{\"1\":1}}],[\"一直到第一学期\",{\"1\":{\"1\":1}}],[\"一点都不惧怕跟别人说出我的这个看起来\",{\"1\":{\"1\":1}}],[\"一提到我的梦想\",{\"1\":{\"1\":1}}],[\"打败美国\",{\"1\":{\"1\":1}}],[\"孟晚舟事件\",{\"1\":{\"1\":1}}],[\"也不能直接将输入的字符串转换为整数形式\",{\"1\":{\"119\":1}}],[\"也不应该丢失数据\",{\"1\":{\"35\":1}}],[\"也应用了method的api\",{\"1\":{\"61\":1}}],[\"也仍要写切点\",{\"1\":{\"52\":1}}],[\"也可以叫点对点的通信\",{\"1\":{\"43\":1}}],[\"也就没法直接new一个对象来调用构造方法了\",{\"1\":{\"60\":1}}],[\"也就是无next指针\",{\"1\":{\"78\":1}}],[\"也就是应用层\",{\"1\":{\"42\":1}}],[\"也就是传输的报文体积更小\",{\"1\":{\"28\":1}}],[\"也就是不用频繁请求\",{\"1\":{\"28\":1}}],[\"也就是不但客户端能向服务端请求资源\",{\"1\":{\"28\":1}}],[\"也就是说\",{\"1\":{\"27\":1}}],[\"也就不会到达数据库了\",{\"1\":{\"22\":1}}],[\"也是apache的顶级开源项目\",{\"1\":{\"8\":1}}],[\"也是参与火星以及未来太空探险旅行的一种方式\",{\"1\":{\"4\":1}}],[\"也会有安全问题\",{\"1\":{\"11\":1}}],[\"也会用到消息\",{\"1\":{\"7\":1}}],[\"也会一直理解负责产品的业务\",{\"1\":{\"3\":1}}],[\"也没有忘记我们的梦想👍你我各自努力\",{\"1\":{\"3\":1}}],[\"也有很多次迷茫\",{\"1\":{\"3\":1}}],[\"也包括消息队列和设计模式\",{\"1\":{\"3\":1}}],[\"也要应该重视底层原理\",{\"1\":{\"2\":1}}],[\"也觉得对社会有很深远的意义\",{\"1\":{\"1\":1}}],[\"也去学院的实验室开始尝试焊电路板\",{\"1\":{\"1\":1}}],[\"也令我很愤怒的事\",{\"1\":{\"1\":1}}],[\"也离不开那天\",{\"1\":{\"0\":1}}],[\"真正和我现在的职业规划搭上关系\",{\"1\":{\"0\":1}}],[\"全世界都在给我让路\",{\"1\":{\"0\":1}}],[\"地触动心灵地大喊\",{\"1\":{\"0\":1}}],[\"离不开长期的努力\",{\"1\":{\"0\":1}}],[\"借着一次上台发言的机会\",{\"1\":{\"0\":1}}],[\"有没有连接多个\",{\"1\":{\"93\":1}}],[\"有很多设计模式的体现\",{\"1\":{\"54\":1}}],[\"有两个很大的优势\",{\"1\":{\"28\":1}}],[\"有宕机的风险\",{\"1\":{\"21\":1}}],[\"有时候不好追溯之前的提交\",{\"1\":{\"16\":1}}],[\"有一部分字段后端数据库表是没有的\",{\"1\":{\"11\":1}}],[\"有一件令我印象很深刻\",{\"1\":{\"1\":1}}],[\"有多励志呢\",{\"1\":{\"0\":1}}],[\"有个面试官问了一个问题\",{\"1\":{\"0\":1}}],[\"我是怎么用spring\",{\"0\":{\"47\":1}}],[\"我是一直打算在后端这个领域深耕的\",{\"1\":{\"3\":1}}],[\"我们观察发现\",{\"1\":{\"104\":1}}],[\"我们要在二维矩阵中找到第一个\",{\"1\":{\"93\":1}}],[\"我们来模拟一下\",{\"1\":{\"78\":1}}],[\"我们注意到\",{\"1\":{\"78\":1}}],[\"我们在业务开发中\",{\"1\":{\"60\":1}}],[\"我们在调用每一个接口的时候\",{\"1\":{\"49\":1}}],[\"我们最前面定义注解的时候\",{\"1\":{\"54\":1}}],[\"我们想对角色权限进行控制\",{\"1\":{\"51\":1}}],[\"我们希望最后的实现效果\",{\"1\":{\"50\":1}}],[\"我们抽出来不是关键业务的同一类方法\",{\"1\":{\"49\":1}}],[\"我们编写业务代码的时候\",{\"1\":{\"49\":1}}],[\"我们分层就是为了让每一层简单\",{\"1\":{\"43\":1}}],[\"我们看见的页面就是既包含文本\",{\"1\":{\"40\":1}}],[\"我们看到的网页\",{\"1\":{\"40\":1}}],[\"我们没有采用http协议\",{\"1\":{\"27\":1}}],[\"我们可以模拟一下两数相加的过程\",{\"1\":{\"120\":1}}],[\"我们可以定义个temp来临时保存cur的下一个指针即可\",{\"1\":{\"78\":1}}],[\"我们可以使用spring\",{\"1\":{\"49\":1}}],[\"我们可以针对请求\",{\"1\":{\"22\":1}}],[\"我们可以在接口层面\",{\"1\":{\"22\":1}}],[\"我们一可以异步\",{\"1\":{\"7\":1}}],[\"我最看中的一点是rocketmq是从阿里内部开源的产品\",{\"1\":{\"8\":1}}],[\"我最后真的上了那所高中\",{\"1\":{\"0\":1}}],[\"我负责做视频上传存储\",{\"1\":{\"7\":1}}],[\"我在弹幕推送系统中为什么用rocketmq\",{\"0\":{\"6\":1}}],[\"我也觉得你超级优秀😉虽然这一路走得并不顺利\",{\"1\":{\"3\":1}}],[\"我也知道了自己的愿望有多强烈\",{\"1\":{\"0\":1}}],[\"我会回到中学时代\",{\"1\":{\"3\":1}}],[\"我会持续关注自己的基础能力\",{\"1\":{\"3\":1}}],[\"我为什么选择了java\",{\"1\":{\"2\":1}}],[\"我为什么选择了计算机\",{\"1\":{\"0\":1}}],[\"我真的做到了\",{\"1\":{\"2\":1}}],[\"我都通过知乎\",{\"1\":{\"1\":1}}],[\"我就两眼发光\",{\"1\":{\"1\":1}}],[\"我要学信息与通信工程这样的专业\",{\"1\":{\"1\":1}}],[\"我要做中国自己的芯片\",{\"1\":{\"1\":1}}],[\"我的火星船票\",{\"0\":{\"4\":1}}],[\"我的目标就是立志进入中国的科技行业\",{\"1\":{\"1\":1}}],[\"我的职业规划是怎样的\",{\"1\":{\"0\":1}}],[\"我现在回想起来都感到无比的震撼和感动\",{\"1\":{\"0\":1}}],[\"我拿着话筒大声告诉台下所有的师生我的梦想\",{\"1\":{\"0\":1}}],[\"我一直都是个很热血的人\",{\"1\":{\"0\":1}}],[\"博学而笃志\",{\"1\":{\"0\":1}}],[\"成为别人\",{\"1\":{\"0\":1}}],[\"而是向右进位\",{\"1\":{\"104\":1}}],[\"而异或操作可以避免这个问题\",{\"1\":{\"66\":1}}],[\"而对于静态代理\",{\"1\":{\"54\":1}}],[\"而这个注解如何工作的具体逻辑\",{\"1\":{\"50\":1}}],[\"而这些操作又不会影响程序本身的正常执行\",{\"1\":{\"49\":1}}],[\"而具体的业务逻辑相当于一个\",{\"1\":{\"49\":1}}],[\"而后端又有很多接口需要进行权限判断\",{\"1\":{\"48\":1}}],[\"而https协议是引入了ssl\",{\"1\":{\"41\":1}}],[\"而不会相互干扰\",{\"1\":{\"34\":1}}],[\"而不会请求数据库\",{\"1\":{\"22\":1}}],[\"而不能\",{\"1\":{\"32\":1}}],[\"而另一半没有执行的情况\",{\"1\":{\"32\":1}}],[\"而服务端并不会主动向客户端推送资源\",{\"1\":{\"27\":1}}],[\"而数据库没有对应的资源\",{\"1\":{\"21\":1}}],[\"而数据库中也没有数据\",{\"1\":{\"21\":1}}],[\"而此时缓存中没有数据\",{\"1\":{\"21\":1}}],[\"而此时热点数据缓存过期\",{\"1\":{\"19\":1}}],[\"而发送一条弹幕后\",{\"1\":{\"7\":1}}],[\"而\",{\"1\":{\"0\":1}}],[\"观察身边的榜样\",{\"1\":{\"0\":1}}],[\"虚心请教也不要忘了关注自己的内心\",{\"1\":{\"0\":1}}],[\"吃了很多的苦\",{\"1\":{\"0\":1}}],[\"谈不上走了很多的路\",{\"1\":{\"0\":1}}],[\"😎about\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
